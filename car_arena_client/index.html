<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8" />
    <title>Car Ball Arena (2D) – v2</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
        :root{
            --bg:#0b1020;
            --panel:#0a0f24;
            --field1:#141a3a;
            --field2:#101534;
            --line:#334155;
            --text:#e5e7eb;
            --muted:#94a3b8;
            --blue:#60a5fa;
            --red:#f87171;
            --ball:#fbbf24;
            --good:#22c55e;
            --shadow-s:
                inset 0 1px 2px hsla(0, 0%, 100%, 0.1),
                0 1px 2px hsla(0, 0%, 0%, 0.3),
                0 2px 4px hsla(0, 0%, 0%, 0.15);
            --shadow-m:
                inset 0 2px 4px hsla(0, 0%, 100%, 0.1),
                0 2px 4px hsla(0, 0%, 0%, 0.3),
                0 4px 8px hsla(0, 0%, 0%, 0.15);
            --shadow-l:
                inset 0 2px 4px hsla(0, 0%, 100%, 0.1),
                0 4px 6px hsla(0, 0%, 0%, 0.3),
                0 6px 10px hsla(0, 0%, 0%, 0.15);
        }

        html,body{
            height:100%; margin:0;
            background:radial-gradient(70% 90% at 50% 10%, #1f2a4a 0%, #040712 60%, #020617 100%);
            color:var(--text);
            font-family:system-ui,-apple-system,Segoe UI,Roboto;
            overflow:hidden;
        }

        canvas{
            display:block; margin:0 auto;
            background:linear-gradient(180deg,var(--field1),var(--field2));
            border-radius:18px;
            box-shadow:0 25px 80px rgba(0,0,0,.55);
        }

        #ui{position:fixed; inset:0; display:grid; place-items:center; padding:18px;}
        .card{
            width:min(92vw,540px);
            background:linear-gradient(180deg,#0b122a,#070b1d);
            border:1px solid #1f2937; border-radius:18px; padding:22px;
            box-shadow: var(--shadow-l);
        }
        .card h1{margin:0 0 10px; font-size:28px; letter-spacing:.2px;}
        .card p{margin:0; color:var(--muted); line-height:1.35;}
        .row{display:flex; gap:12px; margin-top:14px;}
        .divider{height:1px; background:rgba(255,255,255,0.08); margin:14px 0;}

        .input{
            height:42px; padding:0 12px; border-radius:12px;
            border:1px solid rgba(255,255,255,0.10);
            background:rgba(0,0,0,0.28); color:var(--text);
            outline:none; box-shadow: var(--shadow-m);
        }
        .input:focus{border-color:rgba(255,255,255,0.22);}

        button{
            flex:1; padding:12px 14px; border-radius:14px;
            border:1px solid rgba(36, 50, 68, 0.3);
            background:#020617; color:var(--text); cursor:pointer; font-size:16px;
            transition:filter .15s ease-in-out;
            box-shadow: var(--shadow-s);
        }
        button.primary{border:none; background:linear-gradient(135deg,#0ea5e9,#22c55e); color:#041016; font-weight:700; box-shadow: var(--shadow-s);}
        button:hover{filter:brightness(1.08);}

        #hud{
            position:fixed; top:12px; left:50%; transform:translateX(-50%);
            display:flex; gap:14px; align-items:center;
            background:rgba(2,6,23,.55);
            border:1px solid rgba(36, 50, 68, 0.2); border-radius:14px;
            padding:8px 12px; backdrop-filter:blur(10px);
            box-shadow: var(--shadow-m);
        }
        #hud .score{font-size:20px; font-weight:700; letter-spacing:.5px;}
        #hud .hint{font-size:12px; color:var(--muted);}

        .kbd{
            display:inline-block; padding:2px 6px;
            border:1px solid #334155; border-bottom-width:2px; border-radius:7px;
            font-size:12px; color:var(--text); background:#0b1020;
            box-shadow: var(--shadow-s);
        }

        /* Countdown Overlay (DOM) */
        #countdownOverlay{
            position:fixed; left:50%; top:50%; transform:translate(-50%,-50%) scale(.98);
            width:320px; max-width:88vw; pointer-events:none; display:none;
            align-items:center; justify-content:center; z-index:10010; text-align:center;
        }
        #countdownOverlay.visible{ display:flex; animation: popIn .28s cubic-bezier(.2,.9,.2,1); pointer-events:auto; transform:translate(-50%,-50%) scale(1); }
        @keyframes popIn { from { transform: translate(-50%,-50%) scale(.9); opacity:0 } to { transform: translate(-50%,-50%) scale(1); opacity:1 } }
        #countdownOverlay .backdrop{
            position:absolute; inset:0; border-radius:18px;
            background:linear-gradient(180deg, rgba(2,6,23,0.68), rgba(2,6,23,0.78));
            box-shadow: var(--shadow-l); backdrop-filter:blur(8px);
            border:1px solid rgba(255,255,255,0.04);
        }
        #countdownOverlay .box{position:relative; padding:28px 22px; width:100%; display:flex; flex-direction:column; gap:12px; align-items:center;}
        #countdownRing{
            width:120px; height:120px; border-radius:50%;
            background: conic-gradient(var(--blue) 0deg, rgba(255,255,255,0.06) 0deg);
            display:flex; align-items:center; justify-content:center;
            box-shadow: var(--shadow-m);
        }
        #countdownInner{
            width:84px; height:84px; border-radius:50%;
            background:linear-gradient(180deg,#071022,#03101a);
            display:flex; align-items:center; justify-content:center; color:var(--text);
            font-weight:800; font-size:42px; letter-spacing:1px;
            box-shadow: var(--shadow-s);
        }
        #countdownLabel{ color:var(--muted); font-weight:600; font-size:14px; margin-top:4px; }

        /* Settings Panel (floating, rechts unten) */
        #settingsPanel{
            position: fixed;
            right: 20px;
            bottom: 20px;
            z-index:10005;
            display:none; width:320px; max-width:calc(100vw - 40px); max-height:60vh; overflow-y:auto;
            background: linear-gradient(180deg, rgba(22,26,43,0.38), rgba(22,26,43,0.58));
            border:1px solid rgba(255,255,255,0.04); border-radius:18px; padding:16px;
            box-shadow: var(--shadow-l);
            /* angenehme Scrollbar (Firefox + WebKit) */
            scrollbar-width: thin; scrollbar-color: rgba(96,165,250,.45) transparent;
        }
        #settingsPanel.visible{ display:block; }

        /* Header nicht mehr relativ positionieren, damit das X am Panel ausgerichtet wird */
        #settingsPanel .hdr{
            display:flex; align-items:center; gap:10px; margin-bottom:8px; position:static;
            padding-right: 0;
        }
        #settingsPanel .close{
            position: absolute;
            top: 8px;
            right: 8px;
            width: 28px;
            height: 28px;
            margin: 0;
            display: grid;
            place-items: center;

            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.10);
            border-radius: 8px;
            color: var(--muted);
            font-size: 14px;
            cursor: pointer;
            box-shadow: var(--shadow-s);
        }
        #settingsPanel .close:hover{ filter:brightness(1.1); }

        .slider-row{ padding:8px 2px; }
        .slider-label{
            display:flex; align-items:center; justify-content:space-between; gap:10px;
            font-size:13px; margin-bottom:6px;
        }
        #settingsPanel .value{ font-weight:700; color:var(--muted); }

        #settingsPanel input[type="range"]{
            -webkit-appearance:none; appearance:none;
            width:100%; height:10px; border-radius:999px;
            background: linear-gradient(90deg, rgba(255,255,255,0.10), rgba(255,255,255,0.06));
            outline:none;
        }
        #settingsPanel input[type="range"]::-webkit-slider-runnable-track{
            height:10px; border-radius:999px;
            background: linear-gradient(90deg, rgba(96,165,250,0.35), rgba(248,113,113,0.25));
        }
        #settingsPanel input[type="range"]::-webkit-slider-thumb{
            -webkit-appearance:none; appearance:none; margin-top:-6px;
            width:22px; height:22px; border-radius:50%;
            background: radial-gradient(circle at 35% 35%, #fff 0%, #e5e7eb 30%, #c7d2fe 60%, #60a5fa 100%);
            border:1px solid rgba(255,255,255,0.35);
            box-shadow: var(--shadow-s);
            cursor:pointer;
        }
        #settingsPanel input[type="range"]::-moz-range-track{
            height:10px; border-radius:999px;
            background: linear-gradient(90deg, rgba(96,165,250,0.35), rgba(248,113,113,0.25));
        }
        #settingsPanel input[type="range"]::-moz-range-thumb{
            width:22px; height:22px; border-radius:50%;
            background: radial-gradient(circle at 35% 35%, #fff 0%, #e5e7eb 30%, #c7d2fe 60%, #60a5fa 100%);
            border:1px solid rgba(255,255,255,0.35);
            box-shadow: var(--shadow-s);
            cursor:pointer;
        }

        /* Preset-Modal */
        #presetModal{
            position:fixed; inset:0; z-index:10000; display:none;
            align-items:center; justify-content:center;
            backdrop-filter: blur(3px); background: rgba(0,0,0,0.5);
            pointer-events:auto;
        }
        #presetModal.visible{ display:flex; }
        #presetModal .modal-content{
            position:relative; width:min(90vw, 500px); max-height:70vh; overflow-y:auto;
            background: linear-gradient(180deg, #0b122a, #070b1d);
            border:1px solid #1f2937; border-radius:18px; padding:24px;
            box-shadow: var(--shadow-l);
        }
        #presetModal .modal-close{
            position:absolute; top:12px; right:12px; width:32px; height:32px; padding:0; font-size:18px; cursor:pointer;
            background: rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.1); color: var(--text); border-radius:6px;
            box-shadow: var(--shadow-s);
        }
        #presetModal h3{ margin:0 0 16px; font-size:18px; font-weight:800; }
        .preset-item{
            display:flex; gap:8px; margin-bottom:10px; padding:10px;
            background: rgba(255,255,255,0.03); border-radius:10px; align-items:center;
            box-shadow: var(--shadow-s);
        }
        .preset-item .name{ flex:1; font-weight:600; color:var(--text); }
        .preset-item button{ flex:0; padding:6px 8px; font-size:12px; width:auto; box-shadow: var(--shadow-s); }
    </style>
</head>
<body>
<div id="ui">
    <div class="card">
        <div style="display:flex; justify-content:space-between; align-items:center;">
            <h1 style="margin:0;">Car Ball Arena</h1>

        </div>

        <!-- Erste Wahl: Lokal oder Online (keine weiteren Buttons sichtbar bis Auswahl) -->
        <div class="row" id="modeSelect" style="margin-top:6px;">
            <button id="btnLocalChoice" class="primary">Lokal</button>
            <button id="btnOnlineChoice">Online</button>
        </div>

        <div class="divider"></div>
        <button id="btnSettings" style="width:100%; padding:8px 10px; font-size:14px; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.1); display: none;">Advanced Settings⚙️</button>


        <!-- Local-Options (versteckt bis "Lokal" gewählt) -->
        <div id="localOptions" style="margin-top:12px; display:none;">
            <div class="divider"></div>
            <div class="row">
                <button id="pvp" class="primary">Spieler vs Spieler</button>
                <button id="pve">Spieler vs Bot</button>
            </div>
            <div class="divider"></div>
        </div>


        <h2 style="margin:14px 0 8px; font-size:16px; font-weight:800;">Online (Server‑Authoritative)</h2>
        <!-- Online-Options (versteckt bis "Online" gewählt) -->
        <div id="onlineOptions" style="gap:10px; flex-wrap:wrap; display:none;">
            <div class="divider"></div>
            <!-- Variantenauswahl: 1v1 oder 2v2 -->
            <div class="row" style="margin-bottom:8px; align-items:center;">
                <label style="font-weight:700; margin-right:8px; line-height:36px;">Variante:</label>
                <select id="onVariant" class="input" style="width:120px;">
                    <option value="2">1 vs 1</option>
                    <option value="4">2 vs 2</option>
                </select>
            </div>

            <!-- Name-Input für Online -->
            <div class="row" style="margin-bottom:8px; align-items:center;">
                <label style="font-weight:700; margin-right:8px; line-height:36px;">Name:</label>
                <input id="onPlayerName" class="input" placeholder="Dein Name" maxlength="20" style="width:160px;" />
            </div>

            <div class="row" style="gap:10px; flex-wrap:wrap;">
                <button id="onHost" class="primary">Online Host</button>
                <input id="onCode" class="input" placeholder="ROOM CODE" maxlength="6" style="width:140px; text-transform:uppercase;" />
                <button id="onJoin">Join</button>
            </div>
            <p id="onStatus" style="margin-top:10px; color:var(--muted); font-size:13px;">Status: Offline</p>
            <div class="divider"></div>
        </div>

        <div class="divider"></div>
        <p style="margin-top:12px; color:var(--muted)">
            <b>Spieler 1</b>: <span class="kbd">W</span> hoch · <span class="kbd">S</span> runter · <span class="kbd">A</span> links · <span class="kbd">D</span> rechts · <span class="kbd">Space</span> Boost
            <br/>
            <b>Spieler 2</b>: <span class="kbd">↑</span> hoch · <span class="kbd">↓</span> runter · <span class="kbd">←</span> links · <span class="kbd">→</span> rechts · <span class="kbd">Shift</span> Boost
        </p>
    </div>
</div>

<div id="hud" hidden>
    <div class="score"><span id="s1">0</span> : <span id="s2">0</span></div>
    <div class="hint">R = Reset · ESC = Menü</div>
    <div class="hint" id="netHud"></div>
    <div class="hint" id="botState" style="max-width: 520px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"></div>
</div>

<!-- Lobby Overlay: wird beim Host/Join sichtbar -->
<div id="lobby" style="position:fixed; inset:auto 20px 20px 20px; z-index:9998; display:none; align-items:flex-start; pointer-events:auto;">
    <div class="card" style="width:min(92vw,720px); display:flex; gap:14px; flex-direction:column;">
        <h2 style="margin:0 0 6px;">Lobby</h2>
        <div style="display:flex; gap:12px;">
            <div style="flex:1; background:rgba(255,255,255,0.02); padding:10px; border-radius:10px;">
                <div style="font-weight:700; margin-bottom:8px; display:flex; justify-content:space-between; align-items:center;">
                    <span>Team Blau</span>
                    <button id="joinBlue" style="padding:6px 8px; font-size:13px;">Beitreten Blau</button>
                </div>
                <div id="slotsBlue" style="display:flex; flex-direction:column; gap:6px;"></div>
            </div>
            <div style="flex:1; background:rgba(255,255,255,0.02); padding:10px; border-radius:10px;">
                <div style="font-weight:700; margin-bottom:8px; display:flex; justify-content:space-between; align-items:center;">
                    <span>Team Rot</span>
                    <button id="joinRed" style="padding:6px 8px; font-size:13px;">Beitreten Rot</button>
                </div>
                <div id="slotsRed" style="display:flex; flex-direction:column; gap:6px;"></div>
            </div>
        </div>

        <div style="display:flex; justify-content:space-between; gap:12px; margin-top:10px;">
            <div style="color:var(--muted);">Raum: <span id="lobbyCode">—</span> <button id="lobbyCopyBtn" style="padding:4px 8px; font-size:12px; margin-left:6px;">Kopieren</button></div>
            <div style="color:var(--muted);" id="lobbyNotice">Warte auf Spieler…</div>
            <button id="lobbyLeave" style="padding:8px 10px;">Zurück</button>
        </div>
    </div>
</div>

<!-- Countdown Overlay (DOM) -->
<div id="countdownOverlay" aria-hidden="true">
    <div class="backdrop" aria-hidden="true"></div>
    <div class="box">
        <div id="countdownRing" role="status" aria-live="polite">
            <div id="countdownInner">3</div>
        </div>
        <div id="countdownLabel">Spiel startet in</div>
    </div>
</div>

<!-- Floating Settings Panel (rechte Ecke) -->
<div id="settingsPanel" role="dialog" aria-hidden="true" aria-label="Spiel-Einstellungen">
    <div class="hdr">
        <div class="dot" aria-hidden="true"></div>
        <h3>Spiel‑Einstellungen</h3>
        <button class="close" id="settingsClose" title="Schließen">✕</button>
    </div>

    <div class="accent" aria-hidden="true"></div>

    <!-- Preset Quick-Select -->
    <div class="slider-row" style="margin-bottom:8px;">
        <label style="font-weight:700; display:block; margin-bottom:6px;">Preset</label>
        <select id="presetQuickSelect" class="input" style="width:100%;">
            <option value="default">Standard</option>
        </select>
    </div>

    <!-- Sliders (IDs unverändert) -->
    <div class="slider-row">
        <div class="slider-label"><span>Auto‑Beschleunigung</span><span class="value" id="val-carAccel">100%</span></div>
        <input type="range" id="slider-carAccel" min="50" max="150" value="100" step="5">
    </div>

    <div class="slider-row">
        <div class="slider-label"><span>Top‑Geschw.</span><span class="value" id="val-carMaxV">100%</span></div>
        <input type="range" id="slider-carMaxV" min="70" max="130" value="100" step="5">
    </div>

    <div class="slider-row">
        <div class="slider-label"><span>Boost‑Kraft</span><span class="value" id="val-boostAccMul">100%</span></div>
        <input type="range" id="slider-boostAccMul" min="70" max="150" value="100" step="5">
    </div>

    <div class="slider-row">
        <div class="slider-label"><span>Ball‑Trägheit</span><span class="value" id="val-ballDrag">100%</span></div>
        <input type="range" id="slider-ballDrag" min="70" max="130" value="100" step="5">
    </div>

    <div class="slider-row">
        <div class="slider-label"><span>Auto‑Bremse</span><span class="value" id="val-carDrag">100%</span></div>
        <input type="range" id="slider-carDrag" min="50" max="150" value="100" step="5">
    </div>

    <div class="slider-row">
        <div class="slider-label"><span>Boost‑Aufladung</span><span class="value" id="val-boostRegen">100%</span></div>
        <input type="range" id="slider-boostRegen" min="50" max="150" value="100" step="5">
    </div>

    <div class="slider-row">
        <div class="slider-label"><span>Ball‑Elastizität</span><span class="value" id="val-wallBounce">100%</span></div>
        <input type="range" id="slider-wallBounce" min="70" max="140" value="100" step="5">
    </div>

    <div class="slider-row">
        <div class="slider-label"><span>Stoß‑Kraft</span><span class="value" id="val-kickImpulse">100%</span></div>
        <input type="range" id="slider-kickImpulse" min="60" max="150" value="100" step="5">
    </div>

    <div style="display:flex; gap:8px; margin-top:10px;">
        <button id="presetsManageBtn" style="flex:1;">Presets verwalten</button>
        <button id="settingsCloseFooter" style="flex:1;">Schließen</button>
    </div>

</div>

<!-- Preset-Modal (neu hinzugefügt) -->
<div id="presetModal" aria-hidden="true">
    <div class="modal-content" role="dialog" aria-label="Presets verwalten">
        <button class="modal-close" title="Schließen">✕</button>
        <h3>Presets verwalten</h3>
        <div id="presetModalList"></div>
        <div class="row" style="margin-top:10px;">
            <button id="saveNewPresetBtn">Preset speichern</button>
            <button id="presetModalClose">Schließen</button>
        </div>
    </div>
</div>

<canvas id="game" width="960" height="540"></canvas>

<script>
    // =============================
    //  Car Ball Arena – v2
    //  Fokus: direkte Steuerung, echter Boost, smarterer Bot
    //  Struktur: kleine Engine + Entities => leicht erweiterbar
    // =============================

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const ui = document.getElementById('ui');
    const hud = document.getElementById('hud');
    const s1El = document.getElementById('s1');
    const s2El = document.getElementById('s2');
    const botStateEl = document.getElementById('botState');

    const CFG = {
        pad: 44,
        goalWidth: 140,
        goalDepth: 22,
        centerCircle: 64,

        // Bewegung
        carR: 16,
        carMass: 2.2,
        carAcc: 1750,          // px/s^2
        carMaxSpeed: 395,      // px/s
        carDrag: 6.4,          // linear drag

        // Boost
        boostAccMul: 2.1,
        boostMaxMul: 1.75,
        boostDrain: 50,        // energy per second
        boostRegen: 32,        // energy per second

        // Ball
        ballR: 11,
        ballMass: 1.0,
        ballDrag: 0.95,
        restitution: 0.86,

        // Feel
        wallRestitution: 0.86,
        kickImpulse: 340,      // extra kick on hard hits

        // Bot
        botPrediction: 0.42,
        botSwitchX: 0.52,      // switch defense/attack based on ball x
        botStrafe: 0.18,       // small sideways movement so it doesn't beeline
        botBoostDist: 160,
    };
    // ---------- Online (Server-Authoritative via WebSocket) ----------
    // Trage hier deine Render-URL ein (wss://...):
    const WS_URL = "wss://cararena-production.up.railway.app/";

    const NET = {
        ws: null,
        connected: false,
        roomCode: "",
        playerIndex: null,
        lastState: null,
        lastStateAt: 0,
        sendTimer: null,
        seq: 0,
        playerNames: {},  // { 0: "Name1", 1: "Name2", ... }
    };

    // client-seitige Erwartung (für Anzeige bevor Server bestätigt)
    let expectedPlayers = 2;

    function netSetStatus(text){
        const el = document.getElementById('onStatus');
        if (el) el.textContent = 'Status: ' + text;
        const hud = document.getElementById('netHud');
        if (hud){
            hud.textContent = (mode==='online' && NET.connected)
                ? ('Online • Room ' + NET.roomCode + ' • P' + (NET.playerIndex??'?'))
                : '';
        }
    }

    function wsSend(obj){
        if (NET.ws && NET.ws.readyState === 1){
            NET.ws.send(JSON.stringify(obj));
        }
    }

    function netDisconnect(){
        try{ if (NET.sendTimer) clearInterval(NET.sendTimer); }catch{}
        NET.sendTimer = null;
        NET.connected = false;
        NET.lastState = null;
        NET.roomCode = "";
        NET.playerIndex = null;
        if (NET.ws){
            try{ NET.ws.close(); }catch{}
        }
        NET.ws = null;
        netSetStatus('Offline');
    }

    function netConnect(){
        return new Promise((resolve, reject) => {
            if (!WS_URL || WS_URL.includes('YOUR-RENDER-SERVICE')){
                netSetStatus('WS_URL fehlt (im Code eintragen)');
                reject(new Error('WS_URL not set'));
                return;
            }

            netSetStatus('Connecting…');
            const ws = new WebSocket(WS_URL);
            NET.ws = ws;

            ws.onopen = () => {
                NET.connected = true;
                netSetStatus('Connected');
                resolve();
            };
            ws.onclose = () => {
                NET.connected = false;
                netSetStatus('Disconnected');
            };
            ws.onerror = (e) => {
                NET.connected = false;
                netSetStatus('Error');
                reject(e);
            };

            ws.onmessage = (ev) => {
                let msg;
                try{ msg = JSON.parse(ev.data); }catch{ return; }

                if (msg.type === 'room_created'){
                    NET.roomMaxPlayers = msg.maxPlayers || 2;
                    expectedPlayers = NET.roomMaxPlayers;
                    NET.roomCode = msg.code;
                    NET.playerIndex = msg.playerIndex;
                    NET.lastState = null;
                    NET.seq = 0;
                    mode = 'online';
                    // enter lobby (don't start game yet)
                    enterLobby();
                    netSetStatus('Host • Code ' + NET.roomCode);
                    if (msg.cfgPartial) applyOnlineCfg(msg.cfgPartial);
                } else if (msg.type === 'join_ok'){
                    NET.roomMaxPlayers = msg.maxPlayers || 2;
                    expectedPlayers = NET.roomMaxPlayers;
                    NET.roomCode = msg.code;
                    NET.playerIndex = msg.playerIndex;
                    NET.lastState = null;
                    NET.seq = 0;
                    mode = 'online';
                    // enter lobby (don't start game yet)
                    enterLobby();
                    netSetStatus('Joined • Code ' + NET.roomCode);
                    if (msg.cfgPartial) applyOnlineCfg(msg.cfgPartial);
                } else if (msg.type === 'join_failed'){
                    netSetStatus('Join failed: ' + (msg.reason || 'unknown'));
                    // show menu again and hide lobby if we had opened it
                    leaveLobby();
                } else if (msg.type === 'state'){
                    NET.lastState = msg;
                    NET.lastStateAt = performance.now();
                    if (msg.playerNames) NET.playerNames = msg.playerNames;

                    // LOBBY: sicher referenzieren
                    const lobbyEl = document.getElementById('lobby');
                    if (lobbyEl && lobbyEl.style.display === 'block') renderLobby();

                    if (msg.started) {
                        startOnline();
                        if (lobbyEl) lobbyEl.style.display = 'none';
                    }
                    if (msg.cfgPartial) applyOnlineCfg(msg.cfgPartial);
                } else if (msg.type === 'start'){
                    startOnline();
                    const lobbyEl = document.getElementById('lobby');
                    if (lobbyEl) lobbyEl.style.display = 'none';
                } else if (msg.type === 'player_joined' || msg.type === 'player_left'){
                    if (msg.playerNames) { NET.playerNames = msg.playerNames; }
                    const lobbyEl = document.getElementById('lobby');
                    if (lobbyEl && lobbyEl.style.display === 'block') renderLobby();
                } else if (msg.type === 'countdown' || msg.type === 'countdown_cancelled'){
                    if (msg.type === 'countdown') netSetStatus('Starts in ' + msg.remaining);
                    else netSetStatus('Countdown abgebrochen');
                    const lobbyEl = document.getElementById('lobby');
                    if (lobbyEl && lobbyEl.style.display === 'block') renderLobby();
                    showCountdown((typeof msg.remaining === 'number') ? msg.remaining : 0, 3, 'Spiel startet in');
                } else if (msg.type === 'switch_failed'){
                    netSetStatus('Teamwechsel fehlgeschlagen: ' + (msg.reason || 'busy'));
                } else if (msg.type === 'switch_ok'){
                    if (typeof msg.newIndex === 'number') NET.playerIndex = msg.newIndex;
                } else if (msg.type === 'room_closed'){
                    netSetStatus('Room closed');
                    leaveLobby();
                }
            };
        });
    }

    function netLocalInput(){
        // Online: jeder Client steuert genau 1 Spieler (WASD + Space)
        return {
            up: !!Keys['KeyW'],
            down: !!Keys['KeyS'],
            left: !!Keys['KeyA'],
            right: !!Keys['KeyD'],
            boost: !!Keys['Space'],
        };
    }

    function netStartSending(){
        if (NET.sendTimer) clearInterval(NET.sendTimer);
        NET.sendTimer = setInterval(() => {
            if (mode !== 'online' || !NET.connected) return;
            NET.seq++;
            const input = netLocalInput();
            wsSend({ type:'input', input:{...input, seq: NET.seq }});
        }, 16); // ~60 Hz
    }

    function applyServerState(msg){
         // Server nutzt dieselben Pixel-Koordinaten wie das Canvas.
         if (!msg) return;
         if (msg.score){
             score = msg.score;
             s1El.textContent = score[0];
             s2El.textContent = score[1];
         }
         if (msg.ball){
             ball.pos.x = msg.ball.x;
             ball.pos.y = msg.ball.y;
             ball.vel.x = msg.ball.vx || 0;
             ball.vel.y = msg.ball.vy || 0;
         }
        // Namen vom Server übernehmen (Array)
        if (msg.playerNames && typeof msg.playerNames === 'object'){
            NET.playerNames = msg.playerNames;
        }
        // Lobby/Match status vom Server (optional)
        NET.serverStarted = !!msg.started;
        NET.serverCountdown = (typeof msg.countdown === 'number') ? msg.countdown : (msg.countdown === undefined ? undefined : Number(msg.countdown));
         if (msg.car && Array.isArray(msg.car)){
             // stelle sicher, dass lokale Anzeige genug Cars hat
             if (cars.length < msg.car.length){
                 const add = msg.car.length - cars.length;
                 for (let k=0;k<add;k++){
                     const idx = cars.length;
                     const side = (idx % 2 === 0) ? 'left' : 'right';
                     const controls = (idx===0) ? { up:'KeyW', down:'KeyS', left:'KeyA', right:'D', boost:'Space' }
                                    : (idx===1) ? { up:'ArrowUp', down:'ArrowDown', left:'ArrowLeft', right:'ArrowRight', boost:'ShiftRight' }
                                    : { up:null, down:null, left:null, right:null, boost:null };
                     cars.push(new Car({
                         x: canvas.width/2, y: canvas.height/2,
                         color: (idx%2===0) ? getCss('--blue') : getCss('--red'),
                         side,
                         controls,
                         isBot:false
                     }));
                 }
             }
             for (let i=0;i<msg.car.length && i<cars.length;i++){
                 cars[i].pos.x = msg.car[i].x;
                 cars[i].pos.y = msg.car[i].y;
                 cars[i].vel.x = msg.car[i].vx || 0;
                 cars[i].vel.y = msg.car[i].vy || 0;
             }
             if (Array.isArray(msg.energy)){
                 for (let i=0;i<msg.energy.length && i<cars.length;i++){
                     if (msg.energy[i] !== undefined) cars[i].energy = msg.energy[i];
                 }
             }
         }
     }


    // ---------- Input ----------
    const Keys = Object.create(null);
    addEventListener('keydown', (e) => {
        Keys[e.code] = true;
        if (e.code === 'Escape') showMenu();
        if (e.code === 'KeyR') reset(true);
    });
    addEventListener('keyup', (e) => Keys[e.code] = false);

    // ---------- Math ----------
    class Vec {
        constructor(x=0,y=0){this.x=x;this.y=y;}
        clone(){return new Vec(this.x,this.y)}
        set(x,y){this.x=x;this.y=y; return this;}
        add(v){this.x+=v.x; this.y+=v.y; return this;}
        sub(v){this.x-=v.x; this.y-=v.y; return this;}
        mul(s){this.x*=s; this.y*=s; return this;}
        len(){return Math.hypot(this.x,this.y)}
        norm(){const l=this.len()||1; this.x/=l; this.y/=l; return this;}
        dot(v){return this.x*v.x + this.y*v.y}
    }

    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

    // ---------- Entities ----------
    class Car {
        constructor({x,y,color,controls,isBot=false,side='left'}){
            this.pos = new Vec(x,y);
            this.vel = new Vec(0,0);
            this.color = color;
            this.controls = controls;
            this.isBot = isBot;
            this.side = side; // 'left' or 'right'
            this.r = CFG.carR;
            this.mass = CFG.carMass;
            this.energy = 100;
            this.trail = [];
            this.ai = { mode:'', until:0, target:this.pos.clone(), lastDist: 9999, stall: 0, clearSide: 0 }; // Bot-Memory gegen "Zittern"
        }

        getMaxSpeed(isBoosting){
            return CFG.carMaxSpeed * (isBoosting ? CFG.boostMaxMul : 1);
        }

        applyInputDir(dir, isBoosting, dt){
            // dir should be normalized or zero
            if (dir.len() > 1e-6) dir.norm();

            const acc = CFG.carAcc * (isBoosting ? CFG.boostAccMul : 1);
            this.vel.add(dir.mul(acc * dt));

            // cap speed
            const maxV = this.getMaxSpeed(isBoosting);
            const sp = this.vel.len();
            if (sp > maxV) this.vel.norm().mul(maxV);
        }

        inputHuman(dt){
            const c = this.controls;
            // NOTE: Spieler 1: A = links, D = rechts
            const x = (Keys[c.right] ? 1 : 0) + (Keys[c.left] ? -1 : 0);
            const y = (Keys[c.down] ? 1 : 0) + (Keys[c.up] ? -1 : 0);

            let dir = new Vec(x,y);
            // diagonale nicht schneller
            if (dir.len() > 1) dir.norm();

            const wantsBoost = !!Keys[c.boost];
            const isBoosting = wantsBoost && this.energy > 0.1 && dir.len() > 0.01;

            // energy
            if (isBoosting) this.energy = Math.max(0, this.energy - CFG.boostDrain * dt);
            else this.energy = Math.min(100, this.energy + CFG.boostRegen * dt);

            this.applyInputDir(dir, isBoosting, dt);
        }

        inputBot(ball, dt){
            // Bot v3.7 (soccer-ish defending):
            // - MARK/SHADOW: zwischen Gegner/Ball und eigenem Tor stehen (Schussbahn schließen)
            // - INTERCEPT: bei Schüssen Richtung eigenes Tor eine Abfang-Position nehmen
            // - CHALLENGE nur wenn sinnvoll, sonst geduldig blocken (darf auch stehen bleiben)
            // - DRIBBLE/ATTACK wenn Vorteil oder Ball frei

            const now = performance.now();
            const goalLeft  = new Vec(CFG.pad - CFG.goalDepth, canvas.height/2);
            const goalRight = new Vec(canvas.width - (CFG.pad - CFG.goalDepth), canvas.height/2);

            const ownGoal   = (this.side === 'right') ? goalRight : goalLeft;
            const enemyGoal = (this.side === 'right') ? goalLeft  : goalRight;

            // Find opponent und self by index (robust für variable car count)
            let self, opponent;
            for (let i=0;i<cars.length;i++){
                if (cars[i] === this) { self = this; opponent = cars[(i+1)%cars.length]; break; }
            }
            if (!opponent) opponent = cars[cars.length-1]; // fallback

            // Prediction
            const pBall = ball.pos.clone().add(ball.vel.clone().mul(CFG.botPrediction));
            const distBotBall = pBall.clone().sub(this.pos).len();
            const distOppBall = pBall.clone().sub(opponent.pos).len();
            const distBallOwnGoal = pBall.clone().sub(ownGoal).len();

            const ballSpeed = ball.vel.len();
            const inOwnHalf = (this.side === 'right') ? (pBall.x > canvas.width * 0.54) : (pBall.x < canvas.width * 0.46);
            const velTowardOwn = (this.side === 'right') ? (ball.vel.x > 70) : (ball.vel.x < -70);

            // Besitz/Pressure grob schätzen
            const oppNearBall = distOppBall < 120;
            const botNearBall = distBotBall < 120;
            const oppPossess = oppNearBall && (distOppBall + 18 < distBotBall);
            const botPossess = botNearBall && (distBotBall + 18 < distOppBall);

            // Danger: nahe Tor oder Schuss Richtung Tor in eigener Hälfte
            const danger = (distBallOwnGoal < 320) || (inOwnHalf && velTowardOwn && ballSpeed > 60);

            // Safe: Gegner nicht direkt am Ball ODER Bot deutlich näher
            const safeToTake = (distOppBall > 205) || (distBotBall + 50 < distOppBall);

            // Richtungen
            const center = new Vec(canvas.width/2, canvas.height/2);
            const toCenter = center.clone().sub(pBall).norm();

            const rawClearDir = pBall.clone().sub(ownGoal).norm();
            // Clears leicht Richtung Mitte => weniger "komisches" seitliches Gezappel
            const clearDir = rawClearDir.clone().mul(0.72).add(toCenter.clone().mul(0.28)).norm();
            const attackDir = enemyGoal.clone().sub(pBall).norm();

            const offset = this.r + ball.r + 16;

            // -------- Commit Mode (gegen Flip-Flop) --------
            if (!this.ai) this.ai = { mode:'', until:0, target:this.pos.clone(), lastDist: 9999, stall: 0, clearSide: 0 };

            // DRIBBLE-Stall-Erkennung (gegen Weglaufen/Zittern): zählt Frames, in denen Distanz zum Ball größer wird
            if (this.ai.lastDist === 9999) this.ai.lastDist = distBotBall;
            if (distBotBall > this.ai.lastDist + 6) this.ai.stall = (this.ai.stall || 0) + 1;
            else this.ai.stall = 0;
            this.ai.lastDist = distBotBall;

            if (now > this.ai.until){
                let mode;

                // Wenn sehr gefährlich: lieber blocken/klären statt fancy
                if (danger){
                    if (safeToTake || botNearBall) mode = 'CLEAR';
                    else mode = (distBotBall < 165) ? 'CHALLENGE' : 'SHADOW';
                } else {
                    // Nicht gefährlich: wenn Gegner klar am Ball -> markieren, sonst Ball nehmen oder chasen
                    if (oppPossess) mode = 'MARK';
                    else {
                        const advantage = (distBotBall + 55 < distOppBall) || (distOppBall > 235);
                        mode = advantage ? 'DRIBBLE' : 'CHASE';
                    }
                }

                this.ai.mode = mode;
                // längere Commits für stabile Modi (CLEAR/DRIBBLE brauchen Zeit)
                const commitTimes = {
                    'SHADOW': 420,
                    'MARK': 420,
                    'CLEAR': 580,      // länger damit nicht ständig wechsel
                    'DRIBBLE': 580,    // länger damit nicht ständig wechsel
                    'CHALLENGE': 280,
                    'CHASE': 200
                };
                this.ai.until = now + (commitTimes[mode] || 280);
            }

            let mode = this.ai.mode;

            // Wenn DRIBBLE/CLEAR komisch wird (Bot läuft weg / zittert), dann kurz auf CHASE umschalten
            if ((mode === 'DRIBBLE' || mode === 'CLEAR') && this.ai.stall > 16 && distBotBall > 220){
                this.ai.mode = 'CHASE';
                this.ai.until = now + 360;
                this.ai.stall = 0;
                mode = 'CHASE';
            }

            // -------- Intercept Point (wenn Ball Richtung eigenes Tor fliegt) --------
            let interceptY = null;
            if (velTowardOwn && Math.abs(ball.vel.x) > 35){
                const goalLineX = (this.side === 'right') ? (canvas.width - CFG.pad + 6) : (CFG.pad - 6);
                const dx = goalLineX - ball.pos.x;
                const tHit = dx / (ball.vel.x || 1e-6);
                if (tHit > 0 && tHit < 1.2){
                    interceptY = ball.pos.y + ball.vel.y * tHit;
                    interceptY = clamp(interceptY, CFG.pad + 40, canvas.height - CFG.pad - 40);
                }
            }

            // -------- Desired Target --------
            let desired;

            if (mode === 'CLEAR'){
                // Fix gegen "CLEAR-Zittern":
                // Wenn der Bot vor dem Ball ist (zwischen Ball und Clear-Richtung), muss er seitlich "um den Ball herum".
                // Sonst versucht er ständig den Behind-Point zu erreichen, stößt aber am Ball ab => hin und her.

                if (!this.ai.clearSide) this.ai.clearSide = (pBall.y < canvas.height/2) ? 1 : -1; // 1 = unten vorbei, -1 = oben vorbei

                const ballToBot = this.pos.clone().sub(pBall);
                const frontness = ballToBot.dot(clearDir); // >0 = Bot ist vor dem Ball (schlecht zum Klären)

                const perp = new Vec(-clearDir.y, clearDir.x);

                if (frontness > 10){
                    // Umpositionieren: erst seitlich um den Ball, dann hinter ihn
                    const behind = pBall.clone().sub(clearDir.clone().mul(offset * 2.1));
                    desired = behind.add(perp.mul(this.ai.clearSide * offset * 2.8));
                } else {
                    // Hinter/seitlich vom Ball: aktiv durchschieben
                    if (distBotBall < 105) desired = pBall.clone().add(clearDir.clone().mul(offset * 3.6));
                    else desired = pBall.clone().sub(clearDir.clone().mul(offset * 2.2));

                    // sobald wir klar "hinter" dem Ball sind, Side resetten (damit er später neu wählen kann)
                    if (frontness < -18) this.ai.clearSide = 0;
                }

            } else if (mode === 'CHALLENGE'){
                this.ai.clearSide = 0;
                // Direkt rein, aber nicht bis ins Tor "hineinschieben": leicht weg vom Tor anfahren
                desired = pBall.clone().add(clearDir.clone().mul(36));

            } else if (mode === 'DRIBBLE'){
                // Hinter den Ball + wall-aware angle
                let behind = pBall.clone().sub(attackDir.clone().mul(offset * 2.1));

                const nearRight = pBall.x > canvas.width - CFG.pad - 34;
                const nearLeft  = pBall.x < CFG.pad + 34;
                const nearTop   = pBall.y < CFG.pad + 34;
                const nearBot   = pBall.y > canvas.height - CFG.pad - 34;

                if (this.side === 'right' && nearRight){
                    const sign = (pBall.y < canvas.height/2) ? 1 : -1;
                    behind = pBall.clone().add(new Vec(-offset * 1.3, sign * offset * 2.2));
                }
                if (this.side === 'left' && nearLeft){
                    const sign = (pBall.y < canvas.height/2) ? 1 : -1;
                    behind = pBall.clone().add(new Vec( offset * 1.3, sign * offset * 2.2));
                }
                if (nearTop) behind.y = pBall.y + offset * 2.0;
                if (nearBot) behind.y = pBall.y - offset * 2.0;

                const behindDist = behind.clone().sub(this.pos).len();
                // Wenn "behind" viel weiter weg ist als der Ball selbst, dann lieber direkt zum Ball (sonst läuft er weg)
                if (behindDist > distBotBall + 110) desired = pBall.clone();
                else if (distBotBall < 110) desired = pBall.clone().add(attackDir.clone().mul(135));
                else if (behindDist < 60) desired = pBall.clone().add(attackDir.clone().mul(100));
                else desired = behind;

                // Wenn Ball in eigener Ecke klebt: zur Mitte ziehen
                if (inOwnHalf && (nearTop || nearBot)) desired.y = canvas.height/2;

            } else if (mode === 'MARK'){
                // Fußball-like: Gegner begleiten, Schussbahn schließen, Chance zum Abnehmen nutzen
                const threat = opponent.pos.clone();
                const blockDir = threat.clone().sub(ownGoal).norm();
                const blockDist = danger ? 280 : 380;
                desired = ownGoal.clone().add(blockDir.mul(blockDist));

                // etwas zur Ballseite ziehen, um Pässe/Dribbling abzufangen
                desired.x += (pBall.x - desired.x) * 0.1;
                desired.y += (pBall.y - desired.y) * 0.14;

                if (interceptY !== null) desired.y = interceptY;

                // Wenn Ball wirklich frei und nah => abnehmen
                if (safeToTake && distBotBall < 165) desired = pBall.clone();

            } else { // SHADOW / CHASE
                if (danger){
                    // SHADOW: zwischen Ball und eigenem Tor, sehr schwer zu schießen
                    const blockDir = pBall.clone().sub(ownGoal).norm();
                    const blockDist = 190;
                    desired = ownGoal.clone().add(blockDir.mul(blockDist));
                    if (interceptY !== null) desired.y = interceptY;

                    // Wenn es plötzlich safe wird: abnehmen
                    if (safeToTake && distBotBall < 170) desired = pBall.clone();
                } else {
                    // CHASE: aktiv zum Ball
                    desired = pBall.clone();
                }
            }

            // Grenzen
            desired.y = clamp(desired.y, CFG.pad + 45, canvas.height - CFG.pad - 45);

            // -------- Target Smoothing: reduzieren für CLEAR/DRIBBLE (kein über-smoothing) --------
            const slowSmooth = (mode === 'CLEAR' || mode === 'DRIBBLE');
            const alpha = slowSmooth ? (1 - Math.exp(-4 * dt)) : (1 - Math.exp(-10 * dt));  // langsameres smoothing für stabile modes
            this.ai.target.x += (desired.x - this.ai.target.x) * alpha;
            this.ai.target.y += (desired.y - this.ai.target.y) * alpha;

            let dir = this.ai.target.clone().sub(this.pos);
            const dist = dir.len();

            // "Darf stehen bleiben": wenn Ziel erreicht und wir blocken/marken, dann keine Mikro-Bewegung
            const patient = (mode === 'SHADOW' || mode === 'MARK');
            if (patient && dist < 18 && this.vel.len() < 55){
                dir.set(0,0);
                // etwas schneller regenerieren wenn er wirklich wartet
                this.energy = Math.min(100, this.energy + (CFG.boostRegen * 0.65) * dt);
            } else {
                if (dist > 1) dir.mul(1 / dist);
            }

            // Boost nur, wenn es Sinn macht (nicht beim Blocken)
            const canBoost = (mode !== 'SHADOW' && mode !== 'MARK');
            const emergency = danger && (distOppBall + 40 < distBotBall) && dist > 115;
            const wantsBoost = canBoost && (this.energy > 18) && ((dist > CFG.botBoostDist) || emergency);
            const isBoosting = wantsBoost && dir.len() > 0.01;

            if (isBoosting) this.energy = Math.max(0, this.energy - CFG.boostDrain * dt);
            else this.energy = Math.min(100, this.energy + CFG.boostRegen * dt);

            this.applyInputDir(dir, isBoosting, dt);
        }

        integrate(dt){
            // linear drag
            this.vel.mul(Math.exp(-CFG.carDrag * dt));
            this.pos.add(this.vel.clone().mul(dt));

            // keep in field bounds (cars dürfen auch in die Tore reinfahren)
            const p = CFG.pad;
            const cy = canvas.height/2;
            const halfG = CFG.goalWidth/2;
            const inGoalMouth = Math.abs(this.pos.y - cy) < halfG;

            const minX = inGoalMouth ? (p - CFG.goalDepth) : p;
            const maxX = inGoalMouth ? (canvas.width - (p - CFG.goalDepth)) : (canvas.width - p);

            this.pos.x = clamp(this.pos.x, minX, maxX);
            this.pos.y = clamp(this.pos.y, p, canvas.height - p);

            // trail
            this.trail.push({x:this.pos.x, y:this.pos.y, a: clamp(this.vel.len()/this.getMaxSpeed(false),0,1)});
            if (this.trail.length > 14) this.trail.shift();
        }

        draw(){
            // trail
            for (let i=0;i<this.trail.length;i++){
                const t = this.trail[i];
                const k = i / this.trail.length;
                ctx.globalAlpha = 0.08 * k * (0.3 + t.a);
                ctx.beginPath();
                ctx.arc(t.x, t.y, this.r * (0.55 + 0.25*k), 0, Math.PI*2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // body
            ctx.save();
            ctx.translate(this.pos.x, this.pos.y);

            // shadow
            ctx.globalAlpha = 0.22;
            ctx.beginPath();
            ctx.ellipse(0, this.r*0.75, this.r*1.05, this.r*0.55, 0, 0, Math.PI*2);
            ctx.fillStyle = '#000';
            ctx.fill();
            ctx.globalAlpha = 1;

            // car circle base
            ctx.beginPath();
            ctx.arc(0,0,this.r,0,Math.PI*2);
            ctx.fillStyle = this.color;
            ctx.fill();

            // front hint (direction by velocity)
            const v = this.vel.clone();
            if (v.len() > 5) v.norm();
            ctx.beginPath();
            ctx.arc(v.x*this.r*0.65, v.y*this.r*0.65, this.r*0.35, 0, Math.PI*2);
            ctx.fillStyle = 'rgba(2,6,23,.55)';
            ctx.fill();

            // boost bar
            const w = 34, h = 6;
            ctx.translate(0, -this.r - 14);
            ctx.globalAlpha = 0.9;
            ctx.fillStyle = 'rgba(2,6,23,.6)';
            roundRect(ctx, -w/2, -h/2, w, h, 4); ctx.fill();
            ctx.fillStyle = 'rgba(34,197,94,.95)';
            roundRect(ctx, -w/2, -h/2, w*(this.energy/100), h, 4); ctx.fill();
            ctx.globalAlpha = 1;

            ctx.restore();
        }
    }

    class Ball {
        constructor(x,y){
            this.pos = new Vec(x,y);
            this.vel = new Vec(0,0);
            this.r = CFG.ballR;
            this.mass = CFG.ballMass;
        }

        integrate(dt){
            this.vel.mul(Math.exp(-CFG.ballDrag * dt));
            this.pos.add(this.vel.clone().mul(dt));

            // walls with goal openings
            const p = CFG.pad;
            const cy = canvas.height/2;
            const halfG = CFG.goalWidth/2;
            const inGoalMouth = Math.abs(this.pos.y - cy) < halfG;

            // top/bottom
            if (this.pos.y - this.r < p){ this.pos.y = p + this.r; this.vel.y *= -CFG.wallRestitution; }
            if (this.pos.y + this.r > canvas.height - p){ this.pos.y = canvas.height - p - this.r; this.vel.y *= -CFG.wallRestitution; }

            // left/right (bounce unless within goal opening)
            if (!inGoalMouth){
                if (this.pos.x - this.r < p){ this.pos.x = p + this.r; this.vel.x *= -CFG.wallRestitution; }
                if (this.pos.x + this.r > canvas.width - p){ this.pos.x = canvas.width - p - this.r; this.vel.x *= -CFG.wallRestitution; }
            }
        }

        draw(){
            // glow
            ctx.globalAlpha = 0.22;
            ctx.beginPath();
            ctx.arc(this.pos.x, this.pos.y, this.r*2.2, 0, Math.PI*2);
            ctx.fillStyle = '#f59e0b';
            ctx.fill();
            ctx.globalAlpha = 1;

            // ball
            ctx.beginPath();
            ctx.arc(this.pos.x, this.pos.y, this.r, 0, Math.PI*2);
            ctx.fillStyle = getCss('--ball');
            ctx.fill();

            // small highlight
            ctx.globalAlpha = 0.55;
            ctx.beginPath();
            ctx.arc(this.pos.x - this.r*0.25, this.pos.y - this.r*0.35, this.r*0.35, 0, Math.PI*2);
            ctx.fillStyle = '#fff';
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    function getCss(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

    function botModeLabel(mode){
        switch(mode){
            case 'CLEAR': return 'CLEAR (Klären)';
            case 'CHALLENGE': return 'CHALLENGE (Attackieren)';
            case 'SHADOW': return 'SHADOW (Abschirmen)';
            case 'MARK': return 'MARK (Markieren)';
            case 'INTERCEPT': return 'INTERCEPT (Abfangen)';
            case 'DRIBBLE': return 'DRIBBLE (Dribbeln)';
            case 'CHASE': return 'CHASE (Jagen)';
            default: return mode || '';
        }
    }

    function roundRect(c,x,y,w,h,r){
        c.beginPath();
        c.moveTo(x+r,y);
        c.arcTo(x+w,y,x+w,y+h,r);
        c.arcTo(x+w,y+h,x,y+h,r);
        c.arcTo(x,y+h,x,y,r);
        c.arcTo(x,y,x+w,y,r);
        c.closePath();
    }

    // ---------- Physics: collisions ----------
    function resolveCircleCollision(a, b, restitution){
        const n = b.pos.clone().sub(a.pos);
        const dist = n.len();
        const minDist = a.r + b.r;
        if (dist <= 0 || dist >= minDist) return;

        const normal = n.mul(1 / dist); // normalize
        const penetration = minDist - dist;

        // positional correction (split)
        const totalMass = a.mass + b.mass;
        const aMove = penetration * (b.mass / totalMass);
        const bMove = penetration * (a.mass / totalMass);
        a.pos.add(normal.clone().mul(-aMove));
        b.pos.add(normal.clone().mul(bMove));

        // relative velocity
        const rv = b.vel.clone().sub(a.vel);
        const velAlongNormal = rv.dot(normal);
        if (velAlongNormal > 0) return; // separating

        const e = restitution;
        const j = -(1 + e) * velAlongNormal / (1 / a.mass + 1 / b.mass);
        const impulse = normal.clone().mul(j);
        a.vel.add(impulse.clone().mul(-1 / a.mass));
        b.vel.add(impulse.clone().mul( 1 / b.mass));

        // extra kick for fun when cars hit the ball hard
        const hardHit = Math.abs(velAlongNormal);
        if ((a instanceof Car && b instanceof Ball) || (b instanceof Car && a instanceof Ball)){
            if (hardHit > 115){
                const ball = (a instanceof Ball) ? a : b;
                const car = (a instanceof Car) ? a : b;
                ball.vel.add(normal.clone().mul(CFG.kickImpulse * (car.vel.len()/CFG.carMaxSpeed)));
            }
        }
    }

    // ---------- Game State ----------
    let mode = 'pvp';
    let cars = [];
    let ball;
    let score = [0,0];
    let running = false;
    let lastT = 0;

    // local countdown state (für local games)
    let localCountdown = 0;           // Sekunden verbleibend (float)
    let localCountdownActive = false; // true solange Countdown läuft

    function kickoff(){
        ball.pos.set(canvas.width/2, canvas.height/2);
        ball.vel.set((Math.random()*2-1)*120, (Math.random()*2-1)*70);

        cars[0].pos.set(200, canvas.height/2);
        cars[0].vel.set(0,0);
        cars[0].energy = 100;

        cars[1].pos.set(canvas.width-200, canvas.height/2);
        cars[1].vel.set(0,0);
        cars[1].energy = 100;
    }

    function reset(keepScore=false, playersCount=2){
        cars = [];
        for (let i=0;i<playersCount;i++){
            const side = (i % 2 === 0) ? 'left' : 'right';
            const x = (side === 'left') ? 200 : canvas.width - 200;
            const y = (playersCount === 2) ? (canvas.height/2) : (canvas.height/2 + ((i < playersCount/2) ? -40 : 40));
            const controls = (i === 0) ? { up:'KeyW', down:'KeyS', left:'KeyA', right:'KeyD', boost:'Space' }
                            : (i === 1) ? { up:'ArrowUp', down:'ArrowDown', left:'ArrowLeft', right:'ArrowRight', boost:'ShiftRight' }
                            : { up:null, down:null, left:null, right:null, boost:null };
            cars.push(new Car({
                x, y,
                color: i%2===0 ? getCss('--blue') : getCss('--red'),
                side,
                controls,
                isBot: (mode==='pve' && i===1) ? true : false
            }));
        }
        ball = new Ball(canvas.width/2, canvas.height/2);
        if (!keepScore) score = [0,0];
        s1El.textContent = score[0];
        s2El.textContent = score[1];
        kickoff();
    }

    function showMenu(){
        running = false;
        if (mode==='online') netDisconnect();
        ui.style.display = 'grid';
        hud.hidden = true;
        // Hide all option panels, show only main choice
        const lo = document.getElementById('localOptions');
        const on = document.getElementById('onlineOptions');
        if (lo) lo.style.display = 'none';
        if (on) on.style.display = 'none';
        // Settings-Button zusammen mit den Panels ausblenden
        updateSettingsVisibility();
    }


    function startOnline(){
         // Online: wir starten das Rendering, State kommt vom Server
         // vor dem Start Settings-Panel schließen
         document.getElementById('settingsPanel')?.classList.remove('visible');
         ui.style.display = 'none';
         hud.hidden = false;
         // lokale Anzeige mit erwarteter Anzahl (2 oder 4)
         reset(false, expectedPlayers);
         // kein Bot im Online-Modus (alle echten Spieler)
         cars.forEach(c => { if (c) c.isBot = false; });
         // Input senden
         netStartSending();
         running = true;
         lastT = performance.now();
         requestAnimationFrame(loop);
    }

    function start(){
        // bei lokalem Start ebenfalls Settings-Panel schließen
        document.getElementById('settingsPanel')?.classList.remove('visible');
        ui.style.display = 'none';
        hud.hidden = false;
        reset(false);
        // ensure any local countdown stops on fresh start
        localCountdownActive = false;
        localCountdown = 0;
        running = true;
        lastT = performance.now();
        requestAnimationFrame(loop);
    }

    function checkGoals(){
        const cy = canvas.height/2;
        const halfG = CFG.goalWidth/2;

        // left goal: ball must cross beyond left goal depth while inside mouth
        const leftGoalLine = CFG.pad - CFG.goalDepth;
        if (ball.pos.x + ball.r < leftGoalLine && Math.abs(ball.pos.y - cy) < halfG){
            score[1]++;
            s2El.textContent = score[1];
            // local: start short countdown before kickoff (reduced to 1.5s)
            if (mode !== 'online'){
                localCountdown = 1.5;
                localCountdownActive = true;
            }
            return;
        }

        // right goal
        const rightGoalLine = canvas.width - (CFG.pad - CFG.goalDepth);
        if (ball.pos.x - ball.r > rightGoalLine && Math.abs(ball.pos.y - cy) < halfG){
            score[0]++;
            s1El.textContent = score[0];
            if (mode !== 'online'){
                localCountdown = 1.5;
                localCountdownActive = true;
            }
            return;
        }
    }

    // ---------- Rendering ----------
    function drawField(){
        ctx.clearRect(0,0,canvas.width,canvas.height);

        // vignette
        ctx.globalAlpha = 0.22;
        ctx.beginPath();
        ctx.ellipse(canvas.width/2, canvas.height/2, canvas.width*0.56, canvas.height*0.64, 0, 0, Math.PI*2);
        ctx.fillStyle = '#000';
        ctx.fill();
        ctx.globalAlpha = 1;

        // borders
        ctx.strokeStyle = getCss('--line');
        ctx.lineWidth = 2;
        ctx.strokeRect(CFG.pad, CFG.pad, canvas.width-2*CFG.pad, canvas.height-2*CFG.pad);

        // midfield line
        ctx.globalAlpha = 0.65;
        ctx.beginPath();
        ctx.moveTo(canvas.width/2, CFG.pad);
        ctx.lineTo(canvas.width/2, canvas.height-CFG.pad);
        ctx.stroke();
        ctx.globalAlpha = 1;

        // center circle
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.arc(canvas.width/2, canvas.height/2, CFG.centerCircle, 0, Math.PI*2);
        ctx.stroke();
        ctx.globalAlpha = 1;

        // goals
        const cy = canvas.height/2;
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = getCss('--blue');
        ctx.fillRect(0, cy-CFG.goalWidth/2, CFG.pad-3, CFG.goalWidth);
        ctx.fillStyle = getCss('--red');
        ctx.fillRect(canvas.width-(CFG.pad-3), cy-CFG.goalWidth/2, CFG.pad-3, CFG.goalWidth);
        ctx.globalAlpha = 1;

        // goal depth markers
        ctx.globalAlpha = 0.25;
        ctx.fillStyle = '#fff';
        ctx.fillRect(CFG.pad-CFG.goalDepth, cy-CFG.goalWidth/2, 2, CFG.goalWidth);
        ctx.fillRect(canvas.width-(CFG.pad-CFG.goalDepth), cy-CFG.goalWidth/2, 2, CFG.goalWidth);
        ctx.globalAlpha = 1;
    }

    // ---------- Loop ----------
    function step(dt){
        if (mode === 'online'){
            // Server-authoritative: nur State anwenden, keine lokale Physik/Goals
            if (NET.lastState) applyServerState(NET.lastState);
            return;
        }

        // Local countdown active -> pause physics until it runs out
        if (localCountdownActive){
            // inputs are ignored during countdown
            return;
        }

        // input
        cars[0].inputHuman(dt);
        if (cars[1].isBot) cars[1].inputBot(ball, dt);
        else cars[1].inputHuman(dt);

        // integrate
        cars.forEach(c => c.integrate(dt));
        ball.integrate(dt);

        // collisions
        // car-car
        resolveCircleCollision(cars[0], cars[1], 0.35);
        // car-ball
        resolveCircleCollision(cars[0], ball, CFG.restitution);
        resolveCircleCollision(cars[1], ball, CFG.restitution);

        checkGoals();
    }

    function loop(t){
         if (!running) return;
         const dt = clamp((t - lastT) / 1000, 0, 1/30); // stable
         lastT = t;

         // If local countdown active, decrement timer here (so overlay updates) but keep rendering
         if (localCountdownActive){
             localCountdown -= dt;
             if (localCountdown <= 0){
                 localCountdownActive = false;
                 localCountdown = 0;
                 // perform kickoff after countdown
                 kickoff();
             }
         }

         step(dt);

         drawField();
         ball.draw();
         cars.forEach(c => c.draw());

         // Namen anzeigen (lokal oder online)
         if (mode === 'online'){
             cars.forEach((car, idx) => {
                 const name = NET.playerNames[idx] || ('Spieler ' + (idx+1));
                 ctx.save();
                 ctx.globalAlpha = 0.95;
                 ctx.fillStyle = car.color;
                 ctx.font = 'bold 13px system-ui';
                 ctx.textAlign = 'center';
                 // Name höher platzieren, damit er über der Boost/Energieleiste sitzt
                 ctx.fillText(name, car.pos.x, car.pos.y - car.r - 28);
                 ctx.globalAlpha = 1;
                 ctx.restore();
             });
         }

         // Bot-Status im HUD anzeigen
         if (botStateEl){
             if (cars[1] && cars[1].isBot){
                 const m = cars[1].ai?.mode || '';
                 const e = Math.round(cars[1].energy);
                 botStateEl.textContent = `Bot: ${botModeLabel(m)} · Energy: ${e}% · commit: ${(cars[1].ai.until.toFixed(3)-lastT.toFixed(3)).toFixed(1)}s`;
             } else {
                 botStateEl.textContent = '';
             }
         }

         // Countdown Overlay aktualisieren
         if (localCountdownActive){
             updateCountdownRing(localCountdown);
             showCountdown(localCountdown, 3, 'Weiter in');
         } else if (mode === 'online' && NET.lastState && typeof NET.lastState.countdown === 'number' && NET.lastState.countdown > 0){
             // server countdown active
             updateCountdownRing(NET.lastState.countdown);
             showCountdown(NET.lastState.countdown, 3, 'Spiel startet in');
         } else {
             // no countdown active
             hideCountdown();
         }

         requestAnimationFrame(loop);
    }



    // ---------- UI: Init zweistufige Auswahl ----------
    function initUI(){
         const show = id => { const e = document.getElementById(id); if (e) e.style.display = ''; updateSettingsVisibility(); };
         const hide = id => { const e = document.getElementById(id); if (e) e.style.display = 'none'; updateSettingsVisibility(); };

         // Hauptwahl sichtbar, Panels versteckt (sicherstellen)
         hide('localOptions'); hide('onlineOptions');

         // Choice buttons
         const bLocal = document.getElementById('btnLocalChoice');
         const bOnline = document.getElementById('btnOnlineChoice');
         if (bLocal) bLocal.addEventListener('click', () => { show('localOptions'); hide('onlineOptions'); });
         if (bOnline) bOnline.addEventListener('click', () => { show('onlineOptions'); hide('localOptions'); });

         // Local action buttons
         const pvp = document.getElementById('pvp');
         const pve = document.getElementById('pve');
         if (pvp) pvp.addEventListener('click', () => { mode = 'pvp'; start(); });
         if (pve) pve.addEventListener('click', () => { mode = 'pve'; start(); });

         // Online Host / Join
         const onHost = document.getElementById('onHost');
         if (onHost) onHost.addEventListener('click', async () => {
             try{
                 const playerName = (document.getElementById('onPlayerName')?.value || 'Player').trim() || 'Player';
                 await netConnect();
                 const maxP = parseInt(document.getElementById('onVariant')?.value || '2', 10) || 2;
                 expectedPlayers = maxP;
                 // Advanced Settings mitsenden
                 const settings = getCurrentSettings();
                 wsSend({ type:'create_room', maxPlayers: maxP, playerName, settings });
             }catch(e){ console.warn(e); }
         });

         const onJoin = document.getElementById('onJoin');
         if (onJoin) onJoin.addEventListener('click', async () => {
             const code = (document.getElementById('onCode')?.value || '').trim().toUpperCase();
             if (!code){ netSetStatus('Code fehlt'); return; }
             try{
                 const playerName = (document.getElementById('onPlayerName')?.value || 'Player').trim() || 'Player';
                 expectedPlayers = parseInt(document.getElementById('onVariant')?.value || '2',10) || 2;
                 await netConnect();
                 // Join sendet keine Settings (Host bestimmt), Server liefert cfgPartial zurück
                 wsSend({ type:'join_room', code, playerName });
             }catch(e){ console.warn(e); }
         });

         // initial einmal prüfen
         updateSettingsVisibility();
    }

    // Hilfsfunktion: aktuelle Slider-Werte sammeln und als CFG-Overrides senden
    function getCurrentSettings(){
        // Prozentwerte 50..150 → Faktoren 0.5..1.5 oder direkte Werte je Key
        const readPct = (id) => {
            const el = document.getElementById('slider-' + id);
            const v = el ? Number(el.value) : 100;
            return clamp(v, 50, 150) / 100; // Faktor
        };
        // Host sendet nur nicht-feldbezogene Keys
        return {
            carAcc: CFG.carAcc * readPct('carAccel'),
            carMaxSpeed: CFG.carMaxSpeed * readPct('carMaxV'),
            carDrag: CFG.carDrag * readPct('carDrag'),
            boostAccMul: CFG.boostAccMul * readPct('boostAccMul'),
            boostMaxMul: CFG.boostMaxMul * 1, // Top-Speed Multiplikator eher stabil lassen → hier 100% (optional: readPct('boostAccMul') wenn gewünscht)
            boostDrain: CFG.boostDrain * 1,   // Drain nicht zu stark ändern → hier 100% (oder eigener Slider)
            boostRegen: CFG.boostRegen * readPct('boostRegen'),
            ballDrag: CFG.ballDrag * readPct('ballDrag'),
            wallRestitution: CFG.wallRestitution * readPct('wallBounce'),
            kickImpulse: CFG.kickImpulse * readPct('kickImpulse'),
        };
    }

    // Hilfsfunktion: Server-CFG (ohne Feld-Werte) lokal übernehmen für Anzeige/Kosmetik
    function applyOnlineCfg(partial){
        if (!partial || typeof partial !== 'object') return;
        // Nur nicht-feldbezogene Werte übernehmen
        if (partial.carAcc != null) CFG.carAcc = partial.carAcc;
        if (partial.carMaxSpeed != null) CFG.carMaxSpeed = partial.carMaxSpeed;
        if (partial.carDrag != null) CFG.carDrag = partial.carDrag;

        if (partial.boostAccMul != null) CFG.boostAccMul = partial.boostAccMul;
        if (partial.boostMaxMul != null) CFG.boostMaxMul = partial.boostMaxMul;
        if (partial.boostDrain != null) CFG.boostDrain = partial.boostDrain;
        if (partial.boostRegen != null) CFG.boostRegen = partial.boostRegen;

        if (partial.ballDrag != null) CFG.ballDrag = partial.ballDrag;
        if (partial.wallRestitution != null) CFG.wallRestitution = partial.wallRestitution;
        if (partial.kickImpulse != null) CFG.kickImpulse = partial.kickImpulse;
    }

    function netConnect(){
        return new Promise((resolve, reject) => {
            if (!WS_URL || WS_URL.includes('YOUR-RENDER-SERVICE')){
                netSetStatus('WS_URL fehlt (im Code eintragen)');
                reject(new Error('WS_URL not set'));
                return;
            }

            netSetStatus('Connecting…');
            const ws = new WebSocket(WS_URL);
            NET.ws = ws;

            ws.onopen = () => {
                NET.connected = true;
                netSetStatus('Connected');
                resolve();
            };
            ws.onclose = () => {
                NET.connected = false;
                netSetStatus('Disconnected');
            };
            ws.onerror = (e) => {
                NET.connected = false;
                netSetStatus('Error');
                reject(e);
            };

            ws.onmessage = (ev) => {
                let msg;
                try{ msg = JSON.parse(ev.data); }catch{ return; }

                if (msg.type === 'room_created'){
                    NET.roomMaxPlayers = msg.maxPlayers || 2;
                    expectedPlayers = NET.roomMaxPlayers;
                    NET.roomCode = msg.code;
                    NET.playerIndex = msg.playerIndex;
                    NET.lastState = null;
                    NET.seq = 0;
                    mode = 'online';
                    // enter lobby (don't start game yet)
                    enterLobby();
                    netSetStatus('Host • Code ' + NET.roomCode);
                    if (msg.cfgPartial) applyOnlineCfg(msg.cfgPartial);
                } else if (msg.type === 'join_ok'){
                    NET.roomMaxPlayers = msg.maxPlayers || 2;
                    expectedPlayers = NET.roomMaxPlayers;
                    NET.roomCode = msg.code;
                    NET.playerIndex = msg.playerIndex;
                    NET.lastState = null;
                    NET.seq = 0;
                    mode = 'online';
                    // enter lobby (don't start game yet)
                    enterLobby();
                    netSetStatus('Joined • Code ' + NET.roomCode);
                    if (msg.cfgPartial) applyOnlineCfg(msg.cfgPartial);
                } else if (msg.type === 'join_failed'){
                    netSetStatus('Join failed: ' + (msg.reason || 'unknown'));
                    // show menu again and hide lobby if we had opened it
                    leaveLobby();
                } else if (msg.type === 'state'){
                    NET.lastState = msg;
                    NET.lastStateAt = performance.now();
                    if (msg.playerNames) NET.playerNames = msg.playerNames;

                    // LOBBY: sicher referenzieren
                    const lobbyEl = document.getElementById('lobby');
                    if (lobbyEl && lobbyEl.style.display === 'block') renderLobby();

                    if (msg.started) {
                        startOnline();
                        if (lobbyEl) lobbyEl.style.display = 'none';
                    }
                    if (msg.cfgPartial) applyOnlineCfg(msg.cfgPartial);
                } else if (msg.type === 'start'){
                    startOnline();
                    const lobbyEl = document.getElementById('lobby');
                    if (lobbyEl) lobbyEl.style.display = 'none';
                } else if (msg.type === 'player_joined' || msg.type === 'player_left'){
                    if (msg.playerNames) { NET.playerNames = msg.playerNames; }
                    const lobbyEl = document.getElementById('lobby');
                    if (lobbyEl && lobbyEl.style.display === 'block') renderLobby();
                } else if (msg.type === 'countdown' || msg.type === 'countdown_cancelled'){
                    if (msg.type === 'countdown') netSetStatus('Starts in ' + msg.remaining);
                    else netSetStatus('Countdown abgebrochen');
                    const lobbyEl = document.getElementById('lobby');
                    if (lobbyEl && lobbyEl.style.display === 'block') renderLobby();
                    showCountdown((typeof msg.remaining === 'number') ? msg.remaining : 0, 3, 'Spiel startet in');
                } else if (msg.type === 'switch_failed'){
                    netSetStatus('Teamwechsel fehlgeschlagen: ' + (msg.reason || 'busy'));
                } else if (msg.type === 'switch_ok'){
                    if (typeof msg.newIndex === 'number') NET.playerIndex = msg.newIndex;
                } else if (msg.type === 'room_closed'){
                    netSetStatus('Room closed');
                    leaveLobby();
                }
            };
        });
    }

    // ---------- UI: Init zweistufige Auswahl ----------
    function initUI(){
         const show = id => { const e = document.getElementById(id); if (e) e.style.display = ''; updateSettingsVisibility(); };
         const hide = id => { const e = document.getElementById(id); if (e) e.style.display = 'none'; updateSettingsVisibility(); };

         // Hauptwahl sichtbar, Panels versteckt (sicherstellen)
         hide('localOptions'); hide('onlineOptions');

         // Choice buttons
         const bLocal = document.getElementById('btnLocalChoice');
         const bOnline = document.getElementById('btnOnlineChoice');
         if (bLocal) bLocal.addEventListener('click', () => { show('localOptions'); hide('onlineOptions'); });
         if (bOnline) bOnline.addEventListener('click', () => { show('onlineOptions'); hide('localOptions'); });

         // Local action buttons
         const pvp = document.getElementById('pvp');
         const pve = document.getElementById('pve');
         if (pvp) pvp.addEventListener('click', () => { mode = 'pvp'; start(); });
         if (pve) pve.addEventListener('click', () => { mode = 'pve'; start(); });

         // Online Host / Join
         const onHost = document.getElementById('onHost');
         if (onHost) onHost.addEventListener('click', async () => {
             try{
                 const playerName = (document.getElementById('onPlayerName')?.value || 'Player').trim() || 'Player';
                 await netConnect();
                 const maxP = parseInt(document.getElementById('onVariant')?.value || '2', 10) || 2;
                 expectedPlayers = maxP;
                 // Advanced Settings mitsenden
                 const settings = getCurrentSettings();
                 wsSend({ type:'create_room', maxPlayers: maxP, playerName, settings });
             }catch(e){ console.warn(e); }
         });

         const onJoin = document.getElementById('onJoin');
         if (onJoin) onJoin.addEventListener('click', async () => {
             const code = (document.getElementById('onCode')?.value || '').trim().toUpperCase();
             if (!code){ netSetStatus('Code fehlt'); return; }
             try{
                 const playerName = (document.getElementById('onPlayerName')?.value || 'Player').trim() || 'Player';
                 expectedPlayers = parseInt(document.getElementById('onVariant')?.value || '2',10) || 2;
                 await netConnect();
                 // Join sendet keine Settings (Host bestimmt), Server liefert cfgPartial zurück
                 wsSend({ type:'join_room', code, playerName });
             }catch(e){ console.warn(e); }
         });

         // initial einmal prüfen
         updateSettingsVisibility();
    }


    // Settings-Interaktionen initialisieren (Panel öffnen/schließen + Modal)
    function initSliders(){
        const btnSettings = document.getElementById('btnSettings');
        const panel = document.getElementById('settingsPanel');
        const closeHeader = document.getElementById('settingsClose');
        const closeFooter = document.getElementById('settingsCloseFooter');

        const manageBtn = document.getElementById('presetsManageBtn');
        const presetModal = document.getElementById('presetModal');
        const presetModalClose = document.getElementById('presetModalClose');
        const presetModalX = presetModal ? presetModal.querySelector('.modal-close') : null;

        // Panel öffnen/schließen
        if (btnSettings && panel){
            btnSettings.addEventListener('click', () => {
                panel.classList.toggle('visible');
            });
        }
        if (closeHeader && panel){
            closeHeader.addEventListener('click', () => panel.classList.remove('visible'));
        }
        if (closeFooter && panel){
            closeFooter.addEventListener('click', () => panel.classList.remove('visible'));
        }

        // Presets-Modal öffnen/schließen (falls vorhanden)
        if (manageBtn && presetModal){
            manageBtn.addEventListener('click', () => {
                presetModal.classList.add('visible');
            });
        }
        if (presetModalClose && presetModal){
            presetModalClose.addEventListener('click', () => presetModal.classList.remove('visible'));
        }
        if (presetModalX && presetModal){
            presetModalX.addEventListener('click', () => presetModal.classList.remove('visible'));
        }
        if (presetModal){
            // Klick außerhalb schließt Modal
            presetModal.addEventListener('click', (e) => {
                if (e.target === presetModal) presetModal.classList.remove('visible');
            });
        }

        // Panel beim Start automatisch schließen, ohne bestehende Funktionen zu ändern
        document.addEventListener('game:start', () => {
            panel?.classList.remove('visible');
        });
        document.addEventListener('game:startOnline', () => {
            panel?.classList.remove('visible');
        });
    }

    // Settings-Button nur anzeigen, wenn Local- oder Online-Optionen sichtbar sind
    function updateSettingsVisibility(){
        const btn = document.getElementById('btnSettings');
        const lo = document.getElementById('localOptions');
        const on = document.getElementById('onlineOptions');
        if (!btn || !lo || !on) return;
        const loComputed = getComputedStyle(lo).display !== 'none';
        const onComputed = getComputedStyle(on).display !== 'none';
        const visible = loComputed || onComputed;
        btn.style.display = visible ? '' : 'none';
    }

    // Hook: nach Start-Buttons ein Custom-Event feuern, damit initSliders Panel schließen kann
    (function hookStartClosePanel(){
        const origStart = window.start;
        const origStartOnline = window.startOnline;
        if (typeof origStart === 'function'){
            window.start = function(){
                document.dispatchEvent(new Event('game:start'));
                return origStart.apply(this, arguments);
            };
        }
        if (typeof origStartOnline === 'function'){
            window.startOnline = function(){
                document.dispatchEvent(new Event('game:startOnline'));
                return origStartOnline.apply(this, arguments);
            };
        }
    })();

    // Robuste Initialisierung nach DOM-Ready
    (function safeInit(){
        const run = () => {
            try { initUI(); } catch(e){ console.error('initUI error', e); }
            try { initSliders(); } catch(e){ console.error('initSliders error', e); }
        };
        if (document.readyState === 'loading'){
            document.addEventListener('DOMContentLoaded', run, { once:true });
        } else {
            run();
        }
    })();
</script>
</body>
</html>
