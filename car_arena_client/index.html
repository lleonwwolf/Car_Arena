<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8" />
    <title>Car Ball Arena (2D) – v2</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
        :root{
            --bg:#0b1020;
            --panel:#0a0f24;
            --field1:#141a3a;
            --field2:#101534;
            --line:#334155;
            --text:#e5e7eb;
            --muted:#94a3b8;
            --blue:#60a5fa;
            --red:#f87171;
            --ball:#fbbf24;
            --good:#22c55e;
        }
        html,body{height:100%; margin:0; background:radial-gradient(70% 90% at 50% 10%, #1f2a4a 0%, #040712 60%, #020617 100%); color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto; overflow:hidden;}
        canvas{display:block; margin:0 auto; background:linear-gradient(180deg,var(--field1),var(--field2)); border-radius:18px; box-shadow:0 25px 80px rgba(0,0,0,.55);}

        #ui{position:fixed; inset:0; display:grid; place-items:center; padding:18px;}
        .card{width:min(92vw,540px); background:linear-gradient(180deg,#0b122a,#070b1d); border:1px solid #1f2937; border-radius:18px; padding:22px; box-shadow:0 30px 90px rgba(0,0,0,.7);}
        .card h1{margin:0 0 10px; font-size:28px; letter-spacing:.2px;}
        .card p{margin:0; color:var(--muted); line-height:1.35;}
        .row{display:flex; gap:12px; margin-top:14px;}

        .divider{height:1px; background:rgba(255,255,255,0.08); margin:14px 0;}
        .input{
            height:42px; padding:0 12px; border-radius:12px;
            border:1px solid rgba(255,255,255,0.10);
            background:rgba(0,0,0,0.28); color:var(--text);
            outline:none;
        }
        .input:focus{border-color:rgba(255,255,255,0.22);}

        button{flex:1; padding:12px 14px; border-radius:14px; border:1px solid #243244; background:#020617; color:var(--text); cursor:pointer; font-size:16px;}
        button.primary{border:none; background:linear-gradient(135deg,#0ea5e9,#22c55e); color:#041016; font-weight:700;}
        button:hover{filter:brightness(1.08);}

        #hud{position:fixed; top:12px; left:50%; transform:translateX(-50%); display:flex; gap:14px; align-items:center; background:rgba(2,6,23,.55); border:1px solid #1f2937; border-radius:14px; padding:8px 12px; backdrop-filter:blur(10px);}
        #hud .score{font-size:20px; font-weight:700; letter-spacing:.5px;}
        #hud .hint{font-size:12px; color:var(--muted);}

        .kbd{display:inline-block; padding:2px 6px; border:1px solid #334155; border-bottom-width:2px; border-radius:7px; font-size:12px; color:var(--text); background:#0b1020;}
    </style>
</head>
<body>
<div id="ui">
    <div class="card">
        <h1>Car Ball Arena</h1>

        <!-- Erste Wahl: Lokal oder Online (keine weiteren Buttons sichtbar bis Auswahl) -->
        <div class="row" id="modeSelect" style="margin-top:6px;">
            <button id="btnLocalChoice" class="primary">Lokal</button>
            <button id="btnOnlineChoice">Online</button>
        </div>

        <!-- Local-Options (versteckt bis "Lokal" gewählt) -->
        <div id="localOptions" style="margin-top:12px; display:none;">
            <div class="row">
                <button id="pvp" class="primary">Spieler vs Spieler</button>
                <button id="pve">Spieler vs Bot</button>
            </div>
        </div>

        <div class="divider"></div>
        <h2 style="margin:14px 0 8px; font-size:16px; font-weight:800;">Online (Server‑Authoritative)</h2>
        <!-- Online-Options (versteckt bis "Online" gewählt) -->
        <div id="onlineOptions" style="gap:10px; flex-wrap:wrap; display:none;">
            <!-- Variantenauswahl: 1v1 oder 2v2 -->
            <div class="row" style="margin-bottom:8px; align-items:center;">
                <label style="font-weight:700; margin-right:8px; line-height:36px;">Variante:</label>
                <select id="onVariant" class="input" style="width:120px;">
                    <option value="2">1 vs 1</option>
                    <option value="4">2 vs 2</option>
                </select>
            </div>

            <!-- Name-Input für Online -->
            <div class="row" style="margin-bottom:8px; align-items:center;">
                <label style="font-weight:700; margin-right:8px; line-height:36px;">Name:</label>
                <input id="onPlayerName" class="input" placeholder="Dein Name" maxlength="20" style="width:160px;" />
            </div>

            <div class="row" style="gap:10px; flex-wrap:wrap;">
                <button id="onHost" class="primary">Online Host</button>
                <input id="onCode" class="input" placeholder="ROOM CODE" maxlength="6" style="width:140px; text-transform:uppercase;" />
                <button id="onJoin">Join</button>
            </div>
            <p id="onStatus" style="margin-top:10px; color:var(--muted); font-size:13px;">Status: Offline</p>
        </div>

        <p style="margin-top:12px; color:var(--muted)">
            <b>Spieler 1</b>: <span class="kbd">W</span> hoch · <span class="kbd">S</span> runter · <span class="kbd">A</span> links · <span class="kbd">D</span> rechts · <span class="kbd">Space</span> Boost
            <br/>
            <b>Spieler 2</b>: <span class="kbd">↑</span> hoch · <span class="kbd">↓</span> runter · <span class="kbd">←</span> links · <span class="kbd">→</span> rechts · <span class="kbd">Shift</span> Boost
        </p>
    </div>
</div>

<div id="hud" hidden>
    <div class="score"><span id="s1">0</span> : <span id="s2">0</span></div>
    <div class="hint">R = Reset · ESC = Menü</div>
    <div class="hint" id="netHud"></div>
    <div class="hint" id="botState" style="max-width: 520px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"></div>
</div>

<canvas id="game" width="960" height="540"></canvas>

<script>
    // =============================
    //  Car Ball Arena – v2
    //  Fokus: direkte Steuerung, echter Boost, smarterer Bot
    //  Struktur: kleine Engine + Entities => leicht erweiterbar
    // =============================

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const ui = document.getElementById('ui');
    const hud = document.getElementById('hud');
    const s1El = document.getElementById('s1');
    const s2El = document.getElementById('s2');
    const botStateEl = document.getElementById('botState');

    const CFG = {
        pad: 44,
        goalWidth: 140,
        goalDepth: 22,
        centerCircle: 64,

        // Bewegung
        carR: 16,
        carMass: 2.2,
        carAcc: 1750,          // px/s^2
        carMaxSpeed: 395,      // px/s
        carDrag: 6.4,          // linear drag

        // Boost
        boostAccMul: 2.1,
        boostMaxMul: 1.75,
        boostDrain: 50,        // energy per second
        boostRegen: 32,        // energy per second

        // Ball
        ballR: 11,
        ballMass: 1.0,
        ballDrag: 0.95,
        restitution: 0.86,

        // Feel
        wallRestitution: 0.86,
        kickImpulse: 340,      // extra kick on hard hits

        // Bot
        botPrediction: 0.42,
        botSwitchX: 0.52,      // switch defense/attack based on ball x
        botStrafe: 0.18,       // small sideways movement so it doesn't beeline
        botBoostDist: 160,
    };
    // ---------- Online (Server-Authoritative via WebSocket) ----------
    // Trage hier deine Render-URL ein (wss://...):
    const WS_URL = "wss://cararena-production.up.railway.app/";

    const NET = {
        ws: null,
        connected: false,
        roomCode: "",
        playerIndex: null,
        lastState: null,
        lastStateAt: 0,
        sendTimer: null,
        seq: 0,
        playerNames: {},  // { 0: "Name1", 1: "Name2", ... }
    };

    // client-seitige Erwartung (für Anzeige bevor Server bestätigt)
    let expectedPlayers = 2;

    function netSetStatus(text){
        const el = document.getElementById('onStatus');
        if (el) el.textContent = 'Status: ' + text;
        const hud = document.getElementById('netHud');
        if (hud){
            hud.textContent = (mode==='online' && NET.connected)
                ? ('Online • Room ' + NET.roomCode + ' • P' + (NET.playerIndex??'?'))
                : '';
        }
    }

    function wsSend(obj){
        if (NET.ws && NET.ws.readyState === 1){
            NET.ws.send(JSON.stringify(obj));
        }
    }

    function netDisconnect(){
        try{ if (NET.sendTimer) clearInterval(NET.sendTimer); }catch{}
        NET.sendTimer = null;
        NET.connected = false;
        NET.lastState = null;
        NET.roomCode = "";
        NET.playerIndex = null;
        if (NET.ws){
            try{ NET.ws.close(); }catch{}
        }
        NET.ws = null;
        netSetStatus('Offline');
    }

    function netConnect(){
        return new Promise((resolve, reject) => {
            if (!WS_URL || WS_URL.includes('YOUR-RENDER-SERVICE')){
                netSetStatus('WS_URL fehlt (im Code eintragen)');
                reject(new Error('WS_URL not set'));
                return;
            }

            netSetStatus('Connecting…');
            const ws = new WebSocket(WS_URL);
            NET.ws = ws;

            ws.onopen = () => {
                NET.connected = true;
                netSetStatus('Connected');
                resolve();
            };
            ws.onclose = () => {
                NET.connected = false;
                netSetStatus('Disconnected');
            };
            ws.onerror = (e) => {
                NET.connected = false;
                netSetStatus('Error');
                reject(e);
            };

            ws.onmessage = (ev) => {
                let msg;
                try{ msg = JSON.parse(ev.data); }catch{ return; }

                if (msg.type === 'room_created'){
                    // Server gibt nun maxPlayers zurück
                    NET.roomMaxPlayers = msg.maxPlayers || 2;
                    expectedPlayers = NET.roomMaxPlayers;
                    NET.roomCode = msg.code;
                    NET.playerIndex = msg.playerIndex;
                    NET.lastState = null;
                    NET.seq = 0;
                    mode = 'online';
                    startOnline();
                    netSetStatus('Host • Code ' + NET.roomCode);
                } else if (msg.type === 'join_ok'){
                    NET.roomMaxPlayers = msg.maxPlayers || 2;
                    expectedPlayers = NET.roomMaxPlayers;
                    NET.roomCode = msg.code;
                    NET.playerIndex = msg.playerIndex;
                    NET.lastState = null;
                    NET.seq = 0;
                    mode = 'online';
                    startOnline();
                    netSetStatus('Joined • Code ' + NET.roomCode);
                } else if (msg.type === 'join_failed'){
                    netSetStatus('Join failed: ' + (msg.reason || 'unknown'));
                } else if (msg.type === 'state'){
                    NET.lastState = msg;
                    NET.lastStateAt = performance.now();
                } else if (msg.type === 'room_closed'){
                    netSetStatus('Room closed');
                }
            };
        });
    }

    function netLocalInput(){
        // Online: jeder Client steuert genau 1 Spieler (WASD + Space)
        return {
            up: !!Keys['KeyW'],
            down: !!Keys['KeyS'],
            left: !!Keys['KeyA'],
            right: !!Keys['KeyD'],
            boost: !!Keys['Space'],
        };
    }

    function netStartSending(){
        if (NET.sendTimer) clearInterval(NET.sendTimer);
        NET.sendTimer = setInterval(() => {
            if (mode !== 'online' || !NET.connected) return;
            NET.seq++;
            const input = netLocalInput();
            wsSend({ type:'input', input:{...input, seq: NET.seq }});
        }, 66); // ~60 Hz
    }

    function applyServerState(msg){
         // Server nutzt dieselben Pixel-Koordinaten wie das Canvas.
         if (!msg) return;
         if (msg.score){
             score = msg.score;
             s1El.textContent = score[0];
             s2El.textContent = score[1];
         }
         if (msg.ball){
             ball.pos.x = msg.ball.x;
             ball.pos.y = msg.ball.y;
             ball.vel.x = msg.ball.vx || 0;
             ball.vel.y = msg.ball.vy || 0;
         }
        // Namen vom Server übernehmen
        if (msg.playerNames && typeof msg.playerNames === 'object'){
            NET.playerNames = msg.playerNames;
        }
         if (msg.car && Array.isArray(msg.car)){
             // stelle sicher, dass lokale Anzeige genug Cars hat
             if (cars.length < msg.car.length){
                 const add = msg.car.length - cars.length;
                 for (let k=0;k<add;k++){
                     const idx = cars.length;
-                    const side = (idx < (msg.car.length/2)) ? 'left' : 'right';
+                    const side = (idx % 2 === 0) ? 'left' : 'right';
                     const controls = (idx===0) ? { up:'KeyW', down:'KeyS', left:'KeyA', right:'KeyD', boost:'Space' }
                                    : (idx===1) ? { up:'ArrowUp', down:'ArrowDown', left:'ArrowLeft', right:'ArrowRight', boost:'ShiftRight' }
                                    : { up:null, down:null, left:null, right:null, boost:null };
                     cars.push(new Car({
                         x: canvas.width/2, y: canvas.height/2,
                         color: (idx%2===0) ? getCss('--blue') : getCss('--red'),
                         side,
                         controls,
                         isBot:false
                     }));
                 }
             }
             for (let i=0;i<msg.car.length && i<cars.length;i++){
                 cars[i].pos.x = msg.car[i].x;
                 cars[i].pos.y = msg.car[i].y;
                 cars[i].vel.x = msg.car[i].vx || 0;
                 cars[i].vel.y = msg.car[i].vy || 0;
             }
             if (Array.isArray(msg.energy)){
                 for (let i=0;i<msg.energy.length && i<cars.length;i++){
                     if (msg.energy[i] !== undefined) cars[i].energy = msg.energy[i];
                 }
             }
         }
     }


    // ---------- Input ----------
    const Keys = Object.create(null);
    addEventListener('keydown', (e) => {
        Keys[e.code] = true;
        if (e.code === 'Escape') showMenu();
        if (e.code === 'KeyR') reset(true);
    });
    addEventListener('keyup', (e) => Keys[e.code] = false);

    // ---------- Math ----------
    class Vec {
        constructor(x=0,y=0){this.x=x;this.y=y;}
        clone(){return new Vec(this.x,this.y)}
        set(x,y){this.x=x;this.y=y; return this;}
        add(v){this.x+=v.x; this.y+=v.y; return this;}
        sub(v){this.x-=v.x; this.y-=v.y; return this;}
        mul(s){this.x*=s; this.y*=s; return this;}
        len(){return Math.hypot(this.x,this.y)}
        norm(){const l=this.len()||1; this.x/=l; this.y/=l; return this;}
        dot(v){return this.x*v.x + this.y*v.y}
    }

    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

    // ---------- Entities ----------
    class Car {
        constructor({x,y,color,controls,isBot=false,side='left'}){
            this.pos = new Vec(x,y);
            this.vel = new Vec(0,0);
            this.color = color;
            this.controls = controls;
            this.isBot = isBot;
            this.side = side; // 'left' or 'right'
            this.r = CFG.carR;
            this.mass = CFG.carMass;
            this.energy = 100;
            this.trail = [];
            this.ai = { mode:'', until:0, target:this.pos.clone(), lastDist: 9999, stall: 0, clearSide: 0 }; // Bot-Memory gegen "Zittern"
        }

        getMaxSpeed(isBoosting){
            return CFG.carMaxSpeed * (isBoosting ? CFG.boostMaxMul : 1);
        }

        applyInputDir(dir, isBoosting, dt){
            // dir should be normalized or zero
            if (dir.len() > 1e-6) dir.norm();

            const acc = CFG.carAcc * (isBoosting ? CFG.boostAccMul : 1);
            this.vel.add(dir.mul(acc * dt));

            // cap speed
            const maxV = this.getMaxSpeed(isBoosting);
            const sp = this.vel.len();
            if (sp > maxV) this.vel.norm().mul(maxV);
        }

        inputHuman(dt){
            const c = this.controls;
            // NOTE: Spieler 1: A = links, D = rechts
            const x = (Keys[c.right] ? 1 : 0) + (Keys[c.left] ? -1 : 0);
            const y = (Keys[c.down] ? 1 : 0) + (Keys[c.up] ? -1 : 0);

            let dir = new Vec(x,y);
            // diagonale nicht schneller
            if (dir.len() > 1) dir.norm();

            const wantsBoost = !!Keys[c.boost];
            const isBoosting = wantsBoost && this.energy > 0.1 && dir.len() > 0.01;

            // energy
            if (isBoosting) this.energy = Math.max(0, this.energy - CFG.boostDrain * dt);
            else this.energy = Math.min(100, this.energy + CFG.boostRegen * dt);

            this.applyInputDir(dir, isBoosting, dt);
        }

        inputBot(ball, dt){
            // Bot v3.7 (soccer-ish defending):
            // - MARK/SHADOW: zwischen Gegner/Ball und eigenem Tor stehen (Schussbahn schließen)
            // - INTERCEPT: bei Schüssen Richtung eigenes Tor eine Abfang-Position nehmen
            // - CHALLENGE nur wenn sinnvoll, sonst geduldig blocken (darf auch stehen bleiben)
            // - DRIBBLE/ATTACK wenn Vorteil oder Ball frei

            const now = performance.now();
            const goalLeft  = new Vec(CFG.pad - CFG.goalDepth, canvas.height/2);
            const goalRight = new Vec(canvas.width - (CFG.pad - CFG.goalDepth), canvas.height/2);

            const ownGoal   = (this.side === 'right') ? goalRight : goalLeft;
            const enemyGoal = (this.side === 'right') ? goalLeft  : goalRight;

            const opponent = cars[0] === this ? cars[1] : cars[0];
            const self = cars[0] === this ? cars[0] : cars[1];

            // Prediction
            const pBall = ball.pos.clone().add(ball.vel.clone().mul(CFG.botPrediction));
            const distBotBall = pBall.clone().sub(this.pos).len();
            const distOppBall = pBall.clone().sub(opponent.pos).len();
            const distBallOwnGoal = pBall.clone().sub(ownGoal).len();

            const ballSpeed = ball.vel.len();
            const inOwnHalf = (this.side === 'right') ? (pBall.x > canvas.width * 0.54) : (pBall.x < canvas.width * 0.46);
            const velTowardOwn = (this.side === 'right') ? (ball.vel.x > 70) : (ball.vel.x < -70);

            // Besitz/Pressure grob schätzen
            const oppNearBall = distOppBall < 120;
            const botNearBall = distBotBall < 120;
            const oppPossess = oppNearBall && (distOppBall + 18 < distBotBall);
            const botPossess = botNearBall && (distBotBall + 18 < distOppBall);

            // Danger: nahe Tor oder Schuss Richtung Tor in eigener Hälfte
            const danger = (distBallOwnGoal < 320) || (inOwnHalf && velTowardOwn && ballSpeed > 60);

            // Safe: Gegner nicht direkt am Ball ODER Bot deutlich näher
            const safeToTake = (distOppBall > 205) || (distBotBall + 50 < distOppBall);

            // Richtungen
            const center = new Vec(canvas.width/2, canvas.height/2);
            const toCenter = center.clone().sub(pBall).norm();

            const rawClearDir = pBall.clone().sub(ownGoal).norm();
            // Clears leicht Richtung Mitte => weniger "komisches" seitliches Gezappel
            const clearDir = rawClearDir.clone().mul(0.72).add(toCenter.clone().mul(0.28)).norm();
            const attackDir = enemyGoal.clone().sub(pBall).norm();

            const offset = this.r + ball.r + 16;

            // -------- Commit Mode (gegen Flip-Flop) --------
            if (!this.ai) this.ai = { mode:'', until:0, target:this.pos.clone(), lastDist: 9999, stall: 0, clearSide: 0 };

            // DRIBBLE-Stall-Erkennung (gegen Weglaufen/Zittern): zählt Frames, in denen Distanz zum Ball größer wird
            if (this.ai.lastDist === 9999) this.ai.lastDist = distBotBall;
            if (distBotBall > this.ai.lastDist + 6) this.ai.stall = (this.ai.stall || 0) + 1;
            else this.ai.stall = 0;
            this.ai.lastDist = distBotBall;
            if (now > this.ai.until){
                let mode;

                // Wenn sehr gefährlich: lieber blocken/klären statt fancy
                if (danger){
                    if (safeToTake || botNearBall) mode = 'CLEAR';
                    else mode = (distBotBall < 165) ? 'CHALLENGE' : 'SHADOW';
                } else {
                    // Nicht gefährlich: wenn Gegner klar am Ball -> markieren, sonst Ball nehmen oder chasen
                    if (oppPossess) mode = 'MARK';
                    else {
                        const advantage = (distBotBall + 55 < distOppBall) || (distOppBall > 235);
                        mode = advantage ? 'DRIBBLE' : 'CHASE';
                    }
                }

                this.ai.mode = mode;
                // etwas länger committen wenn shadow/mark (stabil), kürzer beim chasen
                const base = (mode === 'SHADOW' || mode === 'MARK') ? 420 : 260;
                this.ai.until = now + base;
            }

            let mode = this.ai.mode;

            // Wenn DRIBBLE komisch wird (Bot läuft weg / zittert), dann kurz auf CHASE umschalten
            if (mode === 'DRIBBLE' && this.ai.stall > 14 && distBotBall > 200){
                this.ai.mode = 'CHASE';
                this.ai.until = now + 10060;
                this.ai.stall = 0;
                mode = 'CHASE';
            }

            // -------- Intercept Point (wenn Ball Richtung eigenes Tor fliegt) --------
            let interceptY = null;
            if (velTowardOwn && Math.abs(ball.vel.x) > 35){
                const goalLineX = (this.side === 'right') ? (canvas.width - CFG.pad + 6) : (CFG.pad - 6);
                const dx = goalLineX - ball.pos.x;
                const tHit = dx / (ball.vel.x || 1e-6);
                if (tHit > 0 && tHit < 1.2){
                    interceptY = ball.pos.y + ball.vel.y * tHit;
                    interceptY = clamp(interceptY, CFG.pad + 40, canvas.height - CFG.pad - 40);
                }
            }

            // -------- Desired Target --------
            let desired;

            if (mode === 'CLEAR'){
                // Fix gegen "CLEAR-Zittern":
                // Wenn der Bot vor dem Ball ist (zwischen Ball und Clear-Richtung), muss er seitlich "um den Ball herum".
                // Sonst versucht er ständig den Behind-Point zu erreichen, stößt aber am Ball ab => hin und her.

                if (!this.ai.clearSide) this.ai.clearSide = (pBall.y < canvas.height/2) ? 1 : -1; // 1 = unten vorbei, -1 = oben vorbei

                const ballToBot = this.pos.clone().sub(pBall);
                const frontness = ballToBot.dot(clearDir); // >0 = Bot ist vor dem Ball (schlecht zum Klären)

                const perp = new Vec(-clearDir.y, clearDir.x);

                if (frontness > 10){
                    // Umpositionieren: erst seitlich um den Ball, dann hinter ihn
                    const behind = pBall.clone().sub(clearDir.clone().mul(offset * 2.1));
                    desired = behind.add(perp.mul(this.ai.clearSide * offset * 2.8));
                } else {
                    // Hinter/seitlich vom Ball: aktiv durchschieben
                    if (distBotBall < 105) desired = pBall.clone().add(clearDir.clone().mul(offset * 3.6));
                    else desired = pBall.clone().sub(clearDir.clone().mul(offset * 2.2));

                    // sobald wir klar "hinter" dem Ball sind, Side resetten (damit er später neu wählen kann)
                    if (frontness < -18) this.ai.clearSide = 0;
                }

            } else if (mode === 'CHALLENGE'){
                this.ai.clearSide = 0;
                // Direkt rein, aber nicht bis ins Tor "hineinschieben": leicht weg vom Tor anfahren
                desired = pBall.clone().add(clearDir.clone().mul(36));

            } else if (mode === 'DRIBBLE'){
                // Hinter den Ball + wall-aware angle
                let behind = pBall.clone().sub(attackDir.clone().mul(offset * 2.1));

                const nearRight = pBall.x > canvas.width - CFG.pad - 34;
                const nearLeft  = pBall.x < CFG.pad + 34;
                const nearTop   = pBall.y < CFG.pad + 34;
                const nearBot   = pBall.y > canvas.height - CFG.pad - 34;

                if (this.side === 'right' && nearRight){
                    const sign = (pBall.y < canvas.height/2) ? 1 : -1;
                    behind = pBall.clone().add(new Vec(-offset * 1.3, sign * offset * 2.2));
                }
                if (this.side === 'left' && nearLeft){
                    const sign = (pBall.y < canvas.height/2) ? 1 : -1;
                    behind = pBall.clone().add(new Vec( offset * 1.3, sign * offset * 2.2));
                }
                if (nearTop) behind.y = pBall.y + offset * 2.0;
                if (nearBot) behind.y = pBall.y - offset * 2.0;

                const behindDist = behind.clone().sub(this.pos).len();
                // Wenn "behind" viel weiter weg ist als der Ball selbst, dann lieber direkt zum Ball (sonst läuft er weg)
                if (behindDist > distBotBall + 110) desired = pBall.clone();
                else if (distBotBall < 110) desired = pBall.clone().add(attackDir.clone().mul(135));
                else if (behindDist < 60) desired = pBall.clone().add(attackDir.clone().mul(100));
                else desired = behind;

                // Wenn Ball in eigener Ecke klebt: zur Mitte ziehen
                if (inOwnHalf && (nearTop || nearBot)) desired.y = canvas.height/2;

            } else if (mode === 'MARK'){
                // Fußball-like: Gegner begleiten, Schussbahn schließen, Chance zum Abnehmen nutzen
                const threat = opponent.pos.clone();
                const blockDir = threat.clone().sub(ownGoal).norm();
                const blockDist = danger ? 280 : 380;
                desired = ownGoal.clone().add(blockDir.mul(blockDist));

                // etwas zur Ballseite ziehen, um Pässe/Dribbling abzufangen
                desired.x += (pBall.x - desired.x) * 0.1;
                desired.y += (pBall.y - desired.y) * 0.14;

                if (interceptY !== null) desired.y = interceptY;

                // Wenn Ball wirklich frei und nah => abnehmen
                if (safeToTake && distBotBall < 165) desired = pBall.clone();

            } else { // SHADOW / CHASE
                if (danger){
                    // SHADOW: zwischen Ball und eigenem Tor, sehr schwer zu schießen
                    const blockDir = pBall.clone().sub(ownGoal).norm();
                    const blockDist = 190;
                    desired = ownGoal.clone().add(blockDir.mul(blockDist));
                    if (interceptY !== null) desired.y = interceptY;

                    // Wenn es plötzlich safe wird: abnehmen
                    if (safeToTake && distBotBall < 170) desired = pBall.clone();
                } else {
                    // CHASE: aktiv zum Ball (aber darf auch mal warten, wenn Position gut)
                    /*if((self.pos.clone().add(ball.pos).add(ball.pos)).norm().sub(ball.pos.clone().add(ownGoal).norm()) <= 0.1 || (self.pos.clone().add(ball.pos).add(ball.pos)).norm().sub(ball.pos.clone().add(ownGoal).norm()) >=0.1)
                    {
                        if(ball.pos.y>540/2){
                            desired = pBall.clone().add();

                        }
                        else{

                        }
                    }
                    else {

                    }*/
                    desired = pBall.clone();
                }
            }

            // Grenzen
            desired.y = clamp(desired.y, CFG.pad + 45, canvas.height - CFG.pad - 45);

            // -------- Target Smoothing --------
            const alpha = 1 - Math.exp(-10 * dt);
            this.ai.target.x += (desired.x - this.ai.target.x) * alpha;
            this.ai.target.y += (desired.y - this.ai.target.y) * alpha;

            let dir = this.ai.target.clone().sub(this.pos);
            const dist = dir.len();

            // "Darf stehen bleiben": wenn Ziel erreicht und wir blocken/marken, dann keine Mikro-Bewegung
            const patient = (mode === 'SHADOW' || mode === 'MARK');
            if (patient && dist < 18 && this.vel.len() < 55){
                dir.set(0,0);
                // etwas schneller regenerieren wenn er wirklich wartet
                this.energy = Math.min(100, this.energy + (CFG.boostRegen * 0.65) * dt);
            } else {
                if (dist > 1) dir.mul(1 / dist);
            }

            // Boost nur, wenn es Sinn macht (nicht beim Blocken)
            const canBoost = (mode !== 'SHADOW' && mode !== 'MARK');
            const emergency = danger && (distOppBall + 40 < distBotBall) && dist > 115;
            const wantsBoost = canBoost && (this.energy > 18) && ((dist > CFG.botBoostDist) || emergency);
            const isBoosting = wantsBoost && dir.len() > 0.01;

            if (isBoosting) this.energy = Math.max(0, this.energy - CFG.boostDrain * dt);
            else this.energy = Math.min(100, this.energy + CFG.boostRegen * dt);

            this.applyInputDir(dir, isBoosting, dt);
        }

        integrate(dt){
            // linear drag
            this.vel.mul(Math.exp(-CFG.carDrag * dt));
            this.pos.add(this.vel.clone().mul(dt));

            // keep in field bounds (cars dürfen auch in die Tore reinfahren)
            const p = CFG.pad;
            const cy = canvas.height/2;
            const halfG = CFG.goalWidth/2;
            const inGoalMouth = Math.abs(this.pos.y - cy) < halfG;

            const minX = inGoalMouth ? (p - CFG.goalDepth) : p;
            const maxX = inGoalMouth ? (canvas.width - (p - CFG.goalDepth)) : (canvas.width - p);

            this.pos.x = clamp(this.pos.x, minX, maxX);
            this.pos.y = clamp(this.pos.y, p, canvas.height - p);

            // trail
            this.trail.push({x:this.pos.x, y:this.pos.y, a: clamp(this.vel.len()/this.getMaxSpeed(false),0,1)});
            if (this.trail.length > 14) this.trail.shift();
        }

        draw(){
            // trail
            for (let i=0;i<this.trail.length;i++){
                const t = this.trail[i];
                const k = i / this.trail.length;
                ctx.globalAlpha = 0.08 * k * (0.3 + t.a);
                ctx.beginPath();
                ctx.arc(t.x, t.y, this.r * (0.55 + 0.25*k), 0, Math.PI*2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // body
            ctx.save();
            ctx.translate(this.pos.x, this.pos.y);

            // shadow
            ctx.globalAlpha = 0.22;
            ctx.beginPath();
            ctx.ellipse(0, this.r*0.75, this.r*1.05, this.r*0.55, 0, 0, Math.PI*2);
            ctx.fillStyle = '#000';
            ctx.fill();
            ctx.globalAlpha = 1;

            // car circle base
            ctx.beginPath();
            ctx.arc(0,0,this.r,0,Math.PI*2);
            ctx.fillStyle = this.color;
            ctx.fill();

            // front hint (direction by velocity)
            const v = this.vel.clone();
            if (v.len() > 5) v.norm();
            ctx.beginPath();
            ctx.arc(v.x*this.r*0.65, v.y*this.r*0.65, this.r*0.35, 0, Math.PI*2);
            ctx.fillStyle = 'rgba(2,6,23,.55)';
            ctx.fill();

            // boost bar
            const w = 34, h = 6;
            ctx.translate(0, -this.r - 14);
            ctx.globalAlpha = 0.9;
            ctx.fillStyle = 'rgba(2,6,23,.6)';
            roundRect(ctx, -w/2, -h/2, w, h, 4); ctx.fill();
            ctx.fillStyle = 'rgba(34,197,94,.95)';
            roundRect(ctx, -w/2, -h/2, w*(this.energy/100), h, 4); ctx.fill();
            ctx.globalAlpha = 1;

            ctx.restore();
        }
    }

    class Ball {
        constructor(x,y){
            this.pos = new Vec(x,y);
            this.vel = new Vec(0,0);
            this.r = CFG.ballR;
            this.mass = CFG.ballMass;
        }

        integrate(dt){
            this.vel.mul(Math.exp(-CFG.ballDrag * dt));
            this.pos.add(this.vel.clone().mul(dt));

            // walls with goal openings
            const p = CFG.pad;
            const cy = canvas.height/2;
            const halfG = CFG.goalWidth/2;
            const inGoalMouth = Math.abs(this.pos.y - cy) < halfG;

            // top/bottom
            if (this.pos.y - this.r < p){ this.pos.y = p + this.r; this.vel.y *= -CFG.wallRestitution; }
            if (this.pos.y + this.r > canvas.height - p){ this.pos.y = canvas.height - p - this.r; this.vel.y *= -CFG.wallRestitution; }

            // left/right (bounce unless within goal opening)
            if (!inGoalMouth){
                if (this.pos.x - this.r < p){ this.pos.x = p + this.r; this.vel.x *= -CFG.wallRestitution; }
                if (this.pos.x + this.r > canvas.width - p){ this.pos.x = canvas.width - p - this.r; this.vel.x *= -CFG.wallRestitution; }
            }
        }

        draw(){
            // glow
            ctx.globalAlpha = 0.22;
            ctx.beginPath();
            ctx.arc(this.pos.x, this.pos.y, this.r*2.2, 0, Math.PI*2);
            ctx.fillStyle = '#f59e0b';
            ctx.fill();
            ctx.globalAlpha = 1;

            // ball
            ctx.beginPath();
            ctx.arc(this.pos.x, this.pos.y, this.r, 0, Math.PI*2);
            ctx.fillStyle = getCss('--ball');
            ctx.fill();

            // small highlight
            ctx.globalAlpha = 0.55;
            ctx.beginPath();
            ctx.arc(this.pos.x - this.r*0.25, this.pos.y - this.r*0.35, this.r*0.35, 0, Math.PI*2);
            ctx.fillStyle = '#fff';
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    function getCss(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

    function botModeLabel(mode){
        switch(mode){
            case 'CLEAR': return 'CLEAR (Klären)';
            case 'CHALLENGE': return 'CHALLENGE (Attackieren)';
            case 'SHADOW': return 'SHADOW (Abschirmen)';
            case 'MARK': return 'MARK (Markieren)';
            case 'INTERCEPT': return 'INTERCEPT (Abfangen)';
            case 'DRIBBLE': return 'DRIBBLE (Dribbeln)';
            case 'CHASE': return 'CHASE (Jagen)';
            default: return mode || '';
        }
    }

    function roundRect(c,x,y,w,h,r){
        c.beginPath();
        c.moveTo(x+r,y);
        c.arcTo(x+w,y,x+w,y+h,r);
        c.arcTo(x+w,y+h,x,y+h,r);
        c.arcTo(x,y+h,x,y,r);
        c.arcTo(x,y,x+w,y,r);
        c.closePath();
    }

    // ---------- Physics: collisions ----------
    function resolveCircleCollision(a, b, restitution){
        const n = b.pos.clone().sub(a.pos);
        const dist = n.len();
        const minDist = a.r + b.r;
        if (dist <= 0 || dist >= minDist) return;

        const normal = n.mul(1 / dist); // normalize
        const penetration = minDist - dist;

        // positional correction (split)
        const totalMass = a.mass + b.mass;
        const aMove = penetration * (b.mass / totalMass);
        const bMove = penetration * (a.mass / totalMass);
        a.pos.add(normal.clone().mul(-aMove));
        b.pos.add(normal.clone().mul(bMove));

        // relative velocity
        const rv = b.vel.clone().sub(a.vel);
        const velAlongNormal = rv.dot(normal);
        if (velAlongNormal > 0) return; // separating

        const e = restitution;
        const j = -(1 + e) * velAlongNormal / (1 / a.mass + 1 / b.mass);
        const impulse = normal.clone().mul(j);
        a.vel.add(impulse.clone().mul(-1 / a.mass));
        b.vel.add(impulse.clone().mul( 1 / b.mass));

        // extra kick for fun when cars hit the ball hard
        const hardHit = Math.abs(velAlongNormal);
        if ((a instanceof Car && b instanceof Ball) || (b instanceof Car && a instanceof Ball)){
            if (hardHit > 115){
                const ball = (a instanceof Ball) ? a : b;
                const car = (a instanceof Car) ? a : b;
                ball.vel.add(normal.clone().mul(CFG.kickImpulse * (car.vel.len()/CFG.carMaxSpeed)));
            }
        }
    }

    // ---------- Game State ----------
    let mode = 'pvp';
    let cars = [];
    let ball;
    let score = [0,0];
    let running = false;
    let lastT = 0;

    function kickoff(){
        ball.pos.set(canvas.width/2, canvas.height/2);
        ball.vel.set((Math.random()*2-1)*120, (Math.random()*2-1)*70);

        cars[0].pos.set(200, canvas.height/2);
        cars[0].vel.set(0,0);
        cars[0].energy = 100;

        cars[1].pos.set(canvas.width-200, canvas.height/2);
        cars[1].vel.set(0,0);
        cars[1].energy = 100;
    }

    function reset(keepScore=false, playersCount=2){
        cars = [];
        for (let i=0;i<playersCount;i++){
            // Abwechselnd links/rechts: 0,2 links (blau), 1,3 rechts (rot)
            const side = (i % 2 === 0) ? 'left' : 'right';
            const x = (side === 'left') ? 200 : canvas.width - 200;
            // Bei 1v1: beide mittig. Bei 2v2: oben/unten Offset
            const y = (playersCount === 2) ? (canvas.height/2) : (canvas.height/2 + ((i < playersCount/2) ? -40 : 40));
             const controls = (i === 0) ? { up:'KeyW', down:'KeyS', left:'KeyA', right:'KeyD', boost:'Space' }
                             : (i === 1) ? { up:'ArrowUp', down:'ArrowDown', left:'ArrowLeft', right:'ArrowRight', boost:'ShiftRight' }
                             : { up:null, down:null, left:null, right:null, boost:null };
             cars.push(new Car({
                 x, y,
                 color: i%2===0 ? getCss('--blue') : getCss('--red'),
                 side,
                 controls,
                 isBot: (mode==='pve' && i===1) ? true : false
             }));
         }
         ball = new Ball(canvas.width/2, canvas.height/2);
         if (!keepScore) score = [0,0];
         s1El.textContent = score[0];
         s2El.textContent = score[1];
         kickoff();
     }

    function showMenu(){
        running = false;
        if (mode==='online') netDisconnect();
        ui.style.display = 'grid';
        hud.hidden = true;
        // Hide all option panels, show only main choice
        const lo = document.getElementById('localOptions');
        const on = document.getElementById('onlineOptions');
        if (lo) lo.style.display = 'none';
        if (on) on.style.display = 'none';
    }


    function startOnline(){
         // Online: wir starten das Rendering, State kommt vom Server
         ui.style.display = 'none';
         hud.hidden = false;
         // lokale Anzeige mit erwarteter Anzahl (2 oder 4)
         reset(false, expectedPlayers);
         // kein Bot im Online-Modus (alle echten Spieler)
         cars.forEach(c => { if (c) c.isBot = false; });
         // Input senden
         netStartSending();
         running = true;
         lastT = performance.now();
         requestAnimationFrame(loop);
     }

    function start(){
        ui.style.display = 'none';
        hud.hidden = false;
        reset(false);
        running = true;
        lastT = performance.now();
        requestAnimationFrame(loop);
    }

    function checkGoals(){
        const cy = canvas.height/2;
        const halfG = CFG.goalWidth/2;

        // left goal: ball must cross beyond left goal depth while inside mouth
        const leftGoalLine = CFG.pad - CFG.goalDepth;
        if (ball.pos.x + ball.r < leftGoalLine && Math.abs(ball.pos.y - cy) < halfG){
            score[1]++; s2El.textContent = score[1]; kickoff();
        }

        // right goal
        const rightGoalLine = canvas.width - (CFG.pad - CFG.goalDepth);
        if (ball.pos.x - ball.r > rightGoalLine && Math.abs(ball.pos.y - cy) < halfG){
            score[0]++; s1El.textContent = score[0]; kickoff();
        }
    }

    // ---------- Rendering ----------
    function drawField(){
        ctx.clearRect(0,0,canvas.width,canvas.height);

        // vignette
        ctx.globalAlpha = 0.22;
        ctx.beginPath();
        ctx.ellipse(canvas.width/2, canvas.height/2, canvas.width*0.56, canvas.height*0.64, 0, 0, Math.PI*2);
        ctx.fillStyle = '#000';
        ctx.fill();
        ctx.globalAlpha = 1;

        // borders
        ctx.strokeStyle = getCss('--line');
        ctx.lineWidth = 2;
        ctx.strokeRect(CFG.pad, CFG.pad, canvas.width-2*CFG.pad, canvas.height-2*CFG.pad);

        // midfield line
        ctx.globalAlpha = 0.65;
        ctx.beginPath();
        ctx.moveTo(canvas.width/2, CFG.pad);
        ctx.lineTo(canvas.width/2, canvas.height-CFG.pad);
        ctx.stroke();
        ctx.globalAlpha = 1;

        // center circle
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.arc(canvas.width/2, canvas.height/2, CFG.centerCircle, 0, Math.PI*2);
        ctx.stroke();
        ctx.globalAlpha = 1;

        // goals
        const cy = canvas.height/2;
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = getCss('--blue');
        ctx.fillRect(0, cy-CFG.goalWidth/2, CFG.pad-3, CFG.goalWidth);
        ctx.fillStyle = getCss('--red');
        ctx.fillRect(canvas.width-(CFG.pad-3), cy-CFG.goalWidth/2, CFG.pad-3, CFG.goalWidth);
        ctx.globalAlpha = 1;

        // goal depth markers
        ctx.globalAlpha = 0.25;
        ctx.fillStyle = '#fff';
        ctx.fillRect(CFG.pad-CFG.goalDepth, cy-CFG.goalWidth/2, 2, CFG.goalWidth);
        ctx.fillRect(canvas.width-(CFG.pad-CFG.goalDepth), cy-CFG.goalWidth/2, 2, CFG.goalWidth);
        ctx.globalAlpha = 1;
    }

    // ---------- Loop ----------
    function step(dt){
        if (mode === 'online'){
            // Server-authoritative: nur State anwenden, keine lokale Physik/Goals
            if (NET.lastState) applyServerState(NET.lastState);
            return;
        }

        // input
        cars[0].inputHuman(dt);
        if (cars[1].isBot) cars[1].inputBot(ball, dt);
        else cars[1].inputHuman(dt);

        // integrate
        cars.forEach(c => c.integrate(dt));
        ball.integrate(dt);

        // collisions
        // car-car
        resolveCircleCollision(cars[0], cars[1], 0.35);
        // car-ball
        resolveCircleCollision(cars[0], ball, CFG.restitution);
        resolveCircleCollision(cars[1], ball, CFG.restitution);

        checkGoals();
    }

    function loop(t){
         if (!running) return;
         const dt = clamp((t - lastT) / 1000, 0, 1/30); // stable
         lastT = t;

         step(dt);

         drawField();
          ball.draw();
          cars.forEach(c => c.draw());

+         // Namen anzeigen (lokal oder online)
+         if (mode === 'online'){
+             cars.forEach((car, idx) => {
+                 const name = NET.playerNames[idx] || ('Spieler ' + (idx+1));
+                 ctx.globalAlpha = 0.95;
+                 ctx.fillStyle = car.color;
+                 ctx.font = 'bold 13px system-ui';
+                 ctx.textAlign = 'center';
+                 ctx.fillText(name, car.pos.x, car.pos.y - car.r - 12);
+                 ctx.globalAlpha = 1;
+             });
+         }

          // Bot-Status im HUD anzeigen
          if (botStateEl){
              if (cars[1] && cars[1].isBot){
                  const m = cars[1].ai?.mode || '';
                  const e = Math.round(cars[1].energy);
                  botStateEl.textContent = `Bot: ${botModeLabel(m)} · Energy: ${e}% · commit: ${(cars[1].ai.until.toFixed(3)-lastT.toFixed(3)).toFixed(1)}s`;
              } else {
                  botStateEl.textContent = '';
              }
          }

          requestAnimationFrame(loop);
     }

    // ---------- UI: Init zweistufige Auswahl ----------
    function initUI(){
         const show = id => { const e = document.getElementById(id); if (e) e.style.display = ''; };
         const hide = id => { const e = document.getElementById(id); if (e) e.style.display = 'none'; };

         // Hauptwahl sichtbar, Panels versteckt (sicherstellen)
         hide('localOptions'); hide('onlineOptions');

         // Choice buttons
         const bLocal = document.getElementById('btnLocalChoice');
         const bOnline = document.getElementById('btnOnlineChoice');
         if (bLocal) bLocal.addEventListener('click', () => { show('localOptions'); hide('onlineOptions'); });
         if (bOnline) bOnline.addEventListener('click', () => { show('onlineOptions'); hide('localOptions'); });

         // Local action buttons
         const pvp = document.getElementById('pvp');
         const pve = document.getElementById('pve');
         if (pvp) pvp.addEventListener('click', () => { mode = 'pvp'; start(); });
         if (pve) pve.addEventListener('click', () => { mode = 'pve'; start(); });

         // Online Host / Join
         const onHost = document.getElementById('onHost');
         if (onHost) onHost.addEventListener('click', async () => {
             try{
                 const playerName = (document.getElementById('onPlayerName')?.value || 'Player').trim() || 'Player';
                 await netConnect();
                 const maxP = parseInt(document.getElementById('onVariant')?.value || '2', 10) || 2;
                 expectedPlayers = maxP;
-                wsSend({ type:'create_room', maxPlayers: maxP });
+                wsSend({ type:'create_room', maxPlayers: maxP, playerName });
             }catch(e){ console.warn(e); }
         });

         const onJoin = document.getElementById('onJoin');
         if (onJoin) onJoin.addEventListener('click', async () => {
             const code = (document.getElementById('onCode')?.value || '').trim().toUpperCase();
             if (!code){ netSetStatus('Code fehlt'); return; }
             try{
+                const playerName = (document.getElementById('onPlayerName')?.value || 'Player').trim() || 'Player';
                 expectedPlayers = parseInt(document.getElementById('onVariant')?.value || '2',10) || 2;
                 await netConnect();
-                wsSend({ type:'join_room', code });
+                wsSend({ type:'join_room', code, playerName });
             }catch(e){ console.warn(e); }
         });
    }

    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initUI);
    else initUI();

    // initial menu sichtbar

    showMenu();
</script>
</body>
</html>
